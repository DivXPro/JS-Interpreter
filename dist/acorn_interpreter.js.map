{"version":3,"sources":["webpack:///webpack/bootstrap 9aacf60eb1b53a92ffa0","webpack:///(webpack)/buildin/global.js","webpack:///./acorn.js","webpack:///(webpack)/buildin/module.js","webpack:///./lib/global.ts","webpack:///./lib/interpreter.ts","webpack:///./node_modules/acorn/dist/acorn.es.js"],"names":["root","mod","exports","module","acorn","version","options","input","inputLen","sourceFile","parse","inpt","opts","String","length","setOptions","initTokenState","parseTopLevel","program","defaultOptions","ecmaVersion","strictSemicolons","allowTrailingCommas","forbidReserved","locations","onComment","ranges","directSourceFile","opt","Object","prototype","hasOwnProperty","call","getLineInfo","offset","line","cur","lineBreak","lastIndex","match","exec","index","column","tokenize","t","getToken","forceRegexp","readToken","start","tokStart","end","tokEnd","startLoc","tokStartLoc","endLoc","tokEndLoc","type","tokType","value","tokVal","jumpTo","pos","reAllowed","tokPos","tokCurLine","tokLineStart","tokRegexpAllowed","skipSpace","lastStart","lastEnd","lastEndLoc","inFunction","labels","strict","raise","message","loc","err","SyntaxError","raisedAt","empty","_num","_regexp","_string","_name","_eof","_break","keyword","_case","beforeExpr","_catch","_continue","_debugger","_default","_do","isLoop","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_while","_with","_new","_this","_null","atomValue","_true","_false","_in","binop","keywordTypes","prefix","_bracketL","_bracketR","_braceL","_braceR","_parenL","_parenR","_comma","_semi","_colon","_dot","_question","_slash","_eq","isAssign","_assign","_incDec","postfix","isUpdate","_prefix","_logicalOR","_logicalAND","_bitwiseOR","_bitwiseXOR","_bitwiseAND","_equality","_relational","_bitShift","_plusMin","_multiplyModulo","tokTypes","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","slash","eq","name","eof","num","regexp","string","kw","makePredicate","words","split","f","cats","out","i","j","push","compareTo","arr","JSON","stringify","sort","a","b","cat","Function","isReservedWord3","isReservedWord5","isStrictReservedWord","isStrictBadIdWord","isKeyword","nonASCIIwhitespace","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","newline","isIdentifierStart","code","test","fromCharCode","isIdentifierChar","line_loc_t","finishToken","val","skipBlockComment","indexOf","slice","skipLineComment","ch","charCodeAt","next","readToken_dot","readNumber","readToken_slash","readRegexp","finishOp","readToken_mult_modulo","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","size","readToken_eq_excl","getTokenFromCode","readHexNumber","readString","readWord","tok","str","content","escaped","inClass","charAt","mods","readWord1","readInt","radix","len","total","e","Infinity","startsWithDot","isFloat","octal","parseFloat","parseInt","quote","readHexChar","n","containsEsc","word","first","esc","escStr","setStrict","strct","lastIndexOf","node_t","node_loc_t","source","startNode","node","range","startNodeFrom","other","finishNode","isUseStrict","stmt","expression","eat","canInsertSemicolon","semicolon","unexpected","expect","checkLVal","expr","body","parseStatement","loopLabel","kind","switchLabel","starttype","isBreak","label","parseIdent","lab","pop","parseParenExpression","parseFor","init","parseVar","declarations","parseForIn","parseExpression","parseFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","block","parseBlock","handler","clause","param","guard","guardedHandlers","finalizer","object","maybeName","allowStrict","oldStrict","update","left","right","noIn","decl","id","noComma","parseMaybeAssign","expressions","parseMaybeConditional","operator","parseExprOps","parseExprOp","parseMaybeUnary","minPrec","prec","op","exprNode","parseExprSubscripts","parseSubscripts","parseExprAtom","base","noCalls","property","computed","callee","arguments","parseExprList","raw","tokStartLoc1","tokStart1","elements","parseObj","parseNew","sawGetSet","properties","prop","key","parsePropertyName","isGetSet","conflict","isStatement","params","oldInFunc","oldLabels","close","allowTrailingComma","allowEmpty","elts","liberal"],"mappings":"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;;;;;;;;;;;AChhHrB;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA,qBAAqB;AACrB;AACA,sBAAsB;AACtB;AACA;;AAEA;;AAEA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,mBAAmB;AACnB,uBAAuB;AACvB,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,mBAAmB;AACnB,uBAAuB;AACvB,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,8BAA8B;AAC5D;AACA,kBAAkB;AAClB,kBAAkB;;AAElB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,mCAAmC;AACnE;AACA,0BAA0B,IAAI,mCAAmC;AACjE,0BAA0B;AAC1B,8BAA8B,mCAAmC;AACjE;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI,mCAAmC;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,iCAAiC;AAC3D,+BAA+B,iCAAiC;AAChE,kCAAkC,8CAA8C;AAChF,mCAAmC,iDAAiD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAA2D;AAC5F;AACA;AACA;AACA,iCAAiC,iBAAiB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+BAA+B;AAChD;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2BAA2B;AAC5C,iCAAiC,2BAA2B;AAC5D,yBAAyB,iDAAiD;AAC1E,qBAAqB,iDAAiD;AACtE,yBAAyB,iDAAiD;AAC1E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA,EAAE,EAAE;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK,yEAAyE;;AAE9E;AACA,KAAK,6BAA6B;;AAElC;AACA,KAAK,iDAAiD;;AAEtD;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA,KAAK,6DAA6D;;AAElE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,0DAA0D;AACjE;AACA,OAAO,8BAA8B;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,OAAO,mCAAmC,QAAQ;AAClD,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,yBAAyB;;AAE9B;AACA;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD,kEAAkE;;AAElE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,sDAAsD;AACtD;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,uEAAuE;AAC9E;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yDAAyD,mBAAmB;AAC5E;;AAEA;AACA;AACA;AACA,OAAO,uEAAuE;AAC9E;AACA,OAAO,aAAa;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,KAAK,8GAA8G;AACnH;AACA,oBAAoB,wDAAwD;AAC5E;;AAEA;AACA;AACA,kBAAkB;AAClB,iBAAiB,4FAA4F;AAC7G;;AAEA;AACA;AACA,KAAK,yEAAyE;AAC9E;AACA,KAAK,yEAAyE;AAC9E;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,mBAAmB;;AAEnB;AACA,wFAAwF;AACxF;AACA;AACA;AACA,uCAAuC,cAAc,MAAM;AAC3D;AACA;AACA,gEAAgE,OAAO;AACvE;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mBAAmB;AAC3E;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kFAAkF;AAC3F;AACA,SAAS,2FAA2F;AACpG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uDAAuD,mBAAmB;AAC1E,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,wBAAwB;AAChC;AACA;AACA,iEAAiE;AACjE,kCAAkC;AAClC;AACA;AACA,iCAAiC,kDAAkD;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sBAAsB;AAC3B;AACA,KAAK,kBAAkB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,wDAAwD;AAC7D;;AAEA;AACA;AACA;;AAEA,uDAAuD,sBAAsB;AAC7E,QAAQ,wCAAwC,kBAAkB;AAClE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,yBAAyB,0EAA0E;AACnG;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA,YAAY,oCAAoC;AAChD,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,4DAA4D;AACjE;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,2DAA2D;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,mBAAmB;AAC5D;AACA;;AAEA;AACA,OAAO;AACP,GAAG;AACH;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA,oBAAoB,wDAAwD;AAC5E;AACA;AACA;AACA;AACA,KAAK,uEAAuE;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK,uCAAuC;AAC5C;AACA,KAAK,wBAAwB;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,8DAA8D;;AAEnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oEAAoE;AACjG,uBAAuB,oEAAoE;AAC3F,0BAA0B,6DAA6D;AACvF,sBAAsB,iEAAiE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gEAAgE;AAC3E;AACA,WAAW,wEAAwE;AACnF,OAAO;AACP;AACA,WAAW,wFAAwF;AACnG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kEAAkE;AACzE;AACA,OAAO,gFAAgF;AACvF;AACA;AACA,GAAG,OAAO,YAAY,YAAY;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6CAA6C,iBAAiB;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,KAAK,+DAA+D;AACpE;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,gDAAgD;AACrD;AACA,KAAK,uCAAuC,iBAAiB;AAC7D;AACA;;AAEA;AACA,OAAO;AACP;AACA,KAAK,yCAAyC,qBAAqB;AACnE;;AAEA,kBAAkB,yCAAyC;AAC3D,KAAK;AACL;AACA,KAAK,4CAA4C;AACjD;AACA,KAAK,kDAAkD;AACvD;;AAEA;AACA;;AAEA,iBAAiB;AACjB,+BAA+B,iBAAiB;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,oDAAoD;AACpD,KAAK,OAAO,eAAe;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,KAAK,OAAO,eAAe;;AAE3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,sFAAsF;AAC/F;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,iBAAiB;AAC9D;;AAEA,iCAAiC,+EAA+E;AAChH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,sCAAsC;AAC7C;AACA,iBAAiB,SAAS;AAC1B;AACA,cAAc,qCAAqC;AACnD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK,mBAAmB;;AAExB;;AAEA;AACA;;AAEA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,eAAe;AAC/B,UAAU,4BAA4B;AACtC;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,wCAAwC,6EAA6E;AACrH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO,iHAAiH;AACxH;AACA;AACA,SAAS,0DAA0D;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,sGAAsG;AAC5H;;AAEA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,qBAAqB;AAClE;;AAEA,eAAe,mDAAmD;AAClE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qCAAqC;AACrC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,2BAA2B,wEAAwE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO,8DAA8D;AACrE,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8EAA8E;AACjH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,KAAK,oCAAoC;AACzC;AACA,uBAAuB,4DAA4D;AACnF;AACA;AACA,kCAAkC,kDAAkD;AACpF;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,GAAG;AACH,iCAAiC,0DAA0D;AAC3F;AACA,4BAA4B,6DAA6D;AACzF,8BAA8B,yDAAyD;AACvF;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+BAA+B;AAChD;AACA;AACA,OAAO,6EAA6E;AACpF,UAAU,iBAAiB;AAC3B;AACA,GAAG;AACH;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA,qEAAqE,iDAAiD;AACtH,mEAAmE,+CAA+C;AAClH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,OAAO,gEAAgE;;AAEvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,oDAAoD;AAC7D;AACA,SAAS,kDAAkD;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,0CAA0C,6EAA6E;AACvH;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;;AAEA,0CAA0C,oCAAoC;AAC9E,sBAAsB,8BAA8B;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kGAAkG;AACzG;AACA,OAAO,+EAA+E;AACtF;AACA;AACA;AACA;AACA,+BAA+B,yFAAyF;AACxH,QAAQ,0BAA0B;AAClC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB;AAC9E;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,KAAK,OAAO,eAAe;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sCAAsC;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,mBAAmB;;AAExB;AACA;AACA;AACA,GAAG;AACH,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8DAA8D;AACvE;AACA,SAAS,sEAAsE;AAC/E,KAAK;AACL;AACA,SAAS,oFAAoF;AAC7F;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,SAAS,qDAAqD;AAC9D;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG,OAAO,mBAAmB;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,oBAAoB;AACzB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK,8BAA8B;AACnC;AACA,KAAK,wBAAwB;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,wBAAwB;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,gHAAgH;AACzH;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,iBAAiB;AACjD;AACA;;AAEA,sCAAsC;AACtC,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,iBAAiB;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mEAAmE;AACnE,KAAK,OAAO,eAAe;;AAE3B;AACA;AACA,OAAO,YAAY;AACnB;AACA;AACA;AACA,SAAS,qDAAqD;AAC9D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK,sFAAsF;AAC3F;AACA,KAAK,4FAA4F;AACjG;AACA,KAAK,0DAA0D;AAC/D;AACA,uDAAuD;AACvD;AACA;AACA,KAAK,0EAA0E;AAC/E;;AAEA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;;AAEA;;AAEA;AACA,uBAAuB,4BAA4B;;AAEnD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,4BAA4B;;AAEnD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC,iBAAiB;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO,aAAa,cAAc,oBAAoB;AAC9E;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO,aAAa,cAAc;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,4CAA4C;AACjD;AACA,KAAK,mDAAmD;AACxD;AACA,KAAK,uBAAuB;AAC5B;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK,oBAAoB;AACzB;AACA,KAAK,qBAAqB;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA,wDAAwD,iCAAiC,EAAE;AAC3F;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,0BAA0B;AAC/B;AACA,KAAK,6BAA6B;AAClC;AACA,KAAK,oCAAoC;AACzC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,mCAAmC;AACxC;AACA;;AAEA;AACA;AACA,KAAK,oBAAoB;AACzB;AACA,KAAK,mCAAmC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,0CAA0C;AACjD;AACA,OAAO,qCAAqC;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,gBAAgB;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,wDAAwD;AAC7D;AACA,KAAK,+BAA+B;AACpC;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK,uCAAuC;;AAE5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,iCAAiC,KAAK;;AAEtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iDAAiD,kBAAkB;;AAEnE;AACA,+BAA+B,oCAAoC;AACnE,sCAAsC;;AAEtC,4BAA4B;AAC5B,QAAQ,0CAA0C;AAClD;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,kDAAkD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yDAAyD;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yDAAyD;AACzD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,qEAAqE;AACrE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA,yBAAyB,YAAY;AACrC,oBAAoB;AACpB;AACA;;AAEA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;;AAEA,0CAA0C;AAC1C;AACA,sBAAsB;AACtB,oBAAoB;AACpB;AACA;;AAEA,mCAAmC;AACnC;AACA,oBAAoB;AACpB;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;;AAEA,yCAAyC;AACzC;AACA,oBAAoB;AACpB,oEAAoE;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,uBAAuB;AACvB,uBAAuB;AACvB,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA,sCAAsC,kCAAkC;AACxE;AACA,wCAAwC,iCAAiC;AACzE,uCAAuC,iCAAiC;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,qCAAqC,8EAA8E;AACnH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT,4CAA4C,wDAAwD;AACpG;AACA,6BAA6B,wDAAwD;AACrF;AACA,uBAAuB,gBAAgB;AACvC,uCAAuC,iBAAiB;AACxD,wCAAwC;AACxC;AACA,KAAK,OAAO,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE,iCAAiC,sDAAsD;AACvF;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,8DAA8D,GAAG;AACjE;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA,gCAAgC,8DAA8D;AAC9F;AACA,SAAS;AACT,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4CAA4C;AACrF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,OAAO;AAC1D;AACA,qBAAqB,sBAAsB,EAAE;AAC7C,0BAA0B,sBAAsB,EAAE;AAClD,wCAAwC,iBAAiB,EAAE;AAC3D,UAAU,gBAAgB;AAC1B,uBAAuB;AACvB;AACA;AACA;AACA,sEAAsE;;AAEtE;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA,oBAAoB,iEAAiE;AACrF,oDAAoD,0DAA0D;AAC9G;AACA;;AAEA;;AAEA;AACA;AACA,oDAAoD,qCAAqC;AACzF,uCAAuC,eAAe;AACtD;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,qCAAqC,YAAY,EAAE;AACnD,oCAAoC,qCAAqC;AACzE;AACA;AACA,oDAAoD,0DAA0D;;AAE9G;AACA,gBAAgB,uBAAuB;AACvC,wCAAwC,yBAAyB;AACjE,yBAAyB,qCAAqC;AAC9D,8BAA8B,yBAAyB;AACvD,QAAQ,wBAAwB;AAChC;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,MAAM;AACzB,uCAAuC,mBAAmB;AAC1D;AACA,iDAAiD;AACjD;AACA,0BAA0B,8DAA8D;AACxF,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT,4CAA4C,4DAA4D;AACxG;AACA,uBAAuB;AACvB,oBAAoB;AACpB;AACA;AACA;AACA,KAAK;AACL,0BAA0B,4DAA4D;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT,4CAA4C,qDAAqD;AACjG;AACA,oFAAoF,YAAY;AAChG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,8BAA8B;AACtC;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,YAAY,EAAE;AACtE;AACA,iCAAiC,2BAA2B,gBAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,mEAAmE;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sBAAsB;AAC3B;AACA;AACA;AACA;AACA,SAAS,oFAAoF;AAC7F;AACA;AACA;AACA,SAAS,+DAA+D;AACxE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,yEAAyE;AACpG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uBAAuB;AACvB;AACA;AACA;;AAEQ","file":"./dist/acorn_interpreter.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9aacf60eb1b53a92ffa0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 0\n// module chunks = 0","// Acorn is a tiny, fast JavaScript parser written in JavaScript.\r\n//\r\n// Acorn was written by Marijn Haverbeke and released under an MIT\r\n// license. The Unicode regexps (for identifiers and whitespace) were\r\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\r\n//\r\n// Git repositories for Acorn are available at\r\n//\r\n//     http://marijnhaverbeke.nl/git/acorn\r\n//     https://github.com/marijnh/acorn.git\r\n//\r\n// Please use the [github bug tracker][ghbt] to report issues.\r\n//\r\n// [ghbt]: https://github.com/marijnh/acorn/issues\r\n//\r\n// This file defines the main parser interface. The library also comes\r\n// with a [error-tolerant parser][dammit] and an\r\n// [abstract syntax tree walker][walk], defined in other files.\r\n//\r\n// [dammit]: acorn_loose.js\r\n// [walk]: util/walk.js\r\n\r\n(function(root, mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports); // CommonJS\r\n  if (typeof define == \"function\" && define.amd) return define([\"exports\"], mod); // AMD\r\n  mod(root.acorn || (root.acorn = {})); // Plain browser env\r\n})(this, function(exports) {\r\n  \"use strict\";\r\n\r\n  exports.version = \"0.4.1\";\r\n\r\n  // The main exported interface (under `self.acorn` when in the\r\n  // browser) is a `parse` function that takes a code string and\r\n  // returns an abstract syntax tree as specified by [Mozilla parser\r\n  // API][api], with the caveat that the SpiderMonkey-specific syntax\r\n  // (`let`, `yield`, inline XML, etc) is not recognized.\r\n  //\r\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\r\n\r\n  var options, input, inputLen, sourceFile;\r\n\r\n  exports.parse = function(inpt, opts) {\r\n    input = String(inpt); inputLen = input.length;\r\n    setOptions(opts);\r\n    initTokenState();\r\n    return parseTopLevel(options.program);\r\n  };\r\n\r\n  // A second optional argument can be given to further configure\r\n  // the parser process. These options are recognized:\r\n\r\n  var defaultOptions = exports.defaultOptions = {\r\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\r\n    // be either 3 or 5. This\r\n    // influences support for strict mode, the set of reserved words, and\r\n    // support for getters and setter.\r\n    ecmaVersion: 5,\r\n    // Turn on `strictSemicolons` to prevent the parser from doing\r\n    // automatic semicolon insertion.\r\n    strictSemicolons: false,\r\n    // When `allowTrailingCommas` is false, the parser will not allow\r\n    // trailing commas in array and object literals.\r\n    allowTrailingCommas: true,\r\n    // By default, reserved words are not enforced. Enable\r\n    // `forbidReserved` to enforce them.\r\n    forbidReserved: false,\r\n    // When `locations` is on, `loc` properties holding objects with\r\n    // `start` and `end` properties in `{line, column}` form (with\r\n    // line being 1-based and column 0-based) will be attached to the\r\n    // nodes.\r\n    locations: false,\r\n    // A function can be passed as `onComment` option, which will\r\n    // cause Acorn to call that function with `(block, text, start,\r\n    // end)` parameters whenever a comment is skipped. `block` is a\r\n    // boolean indicating whether this is a block (`/* */`) comment,\r\n    // `text` is the content of the comment, and `start` and `end` are\r\n    // character offsets that denote the start and end of the comment.\r\n    // When the `locations` option is on, two more parameters are\r\n    // passed, the full `{line, column}` locations of the start and\r\n    // end of the comments.\r\n    onComment: null,\r\n    // Nodes have their start and end characters offsets recorded in\r\n    // `start` and `end` properties (directly on the node, rather than\r\n    // the `loc` object, which holds line/column data. To also add a\r\n    // [semi-standardized][range] `range` property holding a `[start,\r\n    // end]` array with the same numbers, set the `ranges` option to\r\n    // `true`.\r\n    //\r\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\r\n    ranges: false,\r\n    // It is possible to parse multiple files into a single AST by\r\n    // passing the tree produced by parsing the first file as\r\n    // `program` option in subsequent parses. This will add the\r\n    // toplevel forms of the parsed file to the `Program` (top) node\r\n    // of an existing parse tree.\r\n    program: null,\r\n    // When `location` is on, you can pass this to record the source\r\n    // file in every node's `loc` object.\r\n    sourceFile: null,\r\n    // This value, if given, is stored in every node, whether\r\n    // `location` is on or off.\r\n    directSourceFile: null\r\n  };\r\n\r\n  function setOptions(opts) {\r\n    options = opts || {};\r\n    for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\r\n      options[opt] = defaultOptions[opt];\r\n    sourceFile = options.sourceFile || null;\r\n  }\r\n\r\n  // The `getLineInfo` function is mostly useful when the\r\n  // `locations` option is off (for performance reasons) and you\r\n  // want to find the line/column position for a given character\r\n  // offset. `input` should be the code string that the offset refers\r\n  // into.\r\n\r\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\r\n    for (var line = 1, cur = 0;;) {\r\n      lineBreak.lastIndex = cur;\r\n      var match = lineBreak.exec(input);\r\n      if (match && match.index < offset) {\r\n        ++line;\r\n        cur = match.index + match[0].length;\r\n      } else break;\r\n    }\r\n    return {line: line, column: offset - cur};\r\n  };\r\n\r\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\r\n  // The `tokenize` export provides an interface to the tokenizer.\r\n  // Because the tokenizer is optimized for being efficiently used by\r\n  // the Acorn parser itself, this interface is somewhat crude and not\r\n  // very modular. Performing another parse or call to `tokenize` will\r\n  // reset the internal state, and invalidate existing tokenizers.\r\n\r\n  exports.tokenize = function(inpt, opts) {\r\n    input = String(inpt); inputLen = input.length;\r\n    setOptions(opts);\r\n    initTokenState();\r\n\r\n    var t = {};\r\n    function getToken(forceRegexp) {\r\n      readToken(forceRegexp);\r\n      t.start = tokStart; t.end = tokEnd;\r\n      t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\r\n      t.type = tokType; t.value = tokVal;\r\n      return t;\r\n    }\r\n    getToken.jumpTo = function(pos, reAllowed) {\r\n      tokPos = pos;\r\n      if (options.locations) {\r\n        tokCurLine = 1;\r\n        tokLineStart = lineBreak.lastIndex = 0;\r\n        var match;\r\n        while ((match = lineBreak.exec(input)) && match.index < pos) {\r\n          ++tokCurLine;\r\n          tokLineStart = match.index + match[0].length;\r\n        }\r\n      }\r\n      tokRegexpAllowed = reAllowed;\r\n      skipSpace();\r\n    };\r\n    return getToken;\r\n  };\r\n\r\n  // State is kept in (closure-)global variables. We already saw the\r\n  // `options`, `input`, and `inputLen` variables above.\r\n\r\n  // The current position of the tokenizer in the input.\r\n\r\n  var tokPos;\r\n\r\n  // The start and end offsets of the current token.\r\n\r\n  var tokStart, tokEnd;\r\n\r\n  // When `options.locations` is true, these hold objects\r\n  // containing the tokens start and end line/column pairs.\r\n\r\n  var tokStartLoc, tokEndLoc;\r\n\r\n  // The type and value of the current token. Token types are objects,\r\n  // named by variables against which they can be compared, and\r\n  // holding properties that describe them (indicating, for example,\r\n  // the precedence of an infix operator, and the original name of a\r\n  // keyword token). The kind of value that's held in `tokVal` depends\r\n  // on the type of the token. For literals, it is the literal value,\r\n  // for operators, the operator name, and so on.\r\n\r\n  var tokType, tokVal;\r\n\r\n  // Interal state for the tokenizer. To distinguish between division\r\n  // operators and regular expressions, it remembers whether the last\r\n  // token was one that is allowed to be followed by an expression.\r\n  // (If it is, a slash is probably a regexp, if it isn't it's a\r\n  // division operator. See the `parseStatement` function for a\r\n  // caveat.)\r\n\r\n  var tokRegexpAllowed;\r\n\r\n  // When `options.locations` is true, these are used to keep\r\n  // track of the current line, and know when a new line has been\r\n  // entered.\r\n\r\n  var tokCurLine, tokLineStart;\r\n\r\n  // These store the position of the previous token, which is useful\r\n  // when finishing a node and assigning its `end` position.\r\n\r\n  var lastStart, lastEnd, lastEndLoc;\r\n\r\n  // This is the parser's state. `inFunction` is used to reject\r\n  // `return` statements outside of functions, `labels` to verify that\r\n  // `break` and `continue` have somewhere to jump to, and `strict`\r\n  // indicates whether strict mode is on.\r\n\r\n  var inFunction, labels, strict;\r\n\r\n  // This function is used to raise exceptions on parse errors. It\r\n  // takes an offset integer (into the current `input`) to indicate\r\n  // the location of the error, attaches the position to the end\r\n  // of the error message, and then raises a `SyntaxError` with that\r\n  // message.\r\n\r\n  function raise(pos, message) {\r\n    var loc = getLineInfo(input, pos);\r\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\r\n    var err = new SyntaxError(message);\r\n    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;\r\n    throw err;\r\n  }\r\n\r\n  // Reused empty array added for node fields that are always empty.\r\n\r\n  var empty = [];\r\n\r\n  // ## Token types\r\n\r\n  // The assignment of fine-grained, information-carrying type objects\r\n  // allows the tokenizer to store the information it has about a\r\n  // token in a way that is very cheap for the parser to look up.\r\n\r\n  // All token type variables start with an underscore, to make them\r\n  // easy to recognize.\r\n\r\n  // These are the general types. The `type` property is only used to\r\n  // make them recognizeable when debugging.\r\n\r\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\r\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\r\n\r\n  // Keyword tokens. The `keyword` property (also used in keyword-like\r\n  // operators) indicates that the token originated from an\r\n  // identifier-like word, which is used when parsing property names.\r\n  //\r\n  // The `beforeExpr` property is used to disambiguate between regular\r\n  // expressions and divisions. It is set on all token types that can\r\n  // be followed by an expression (thus, a slash after them would be a\r\n  // regular expression).\r\n  //\r\n  // `isLoop` marks a keyword as starting a loop, which is important\r\n  // to know when parsing a label, in order to allow or disallow\r\n  // continue jumps to that label.\r\n\r\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\r\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\r\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\r\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\r\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\r\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\r\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\r\n  var _this = {keyword: \"this\"};\r\n\r\n  // The keywords that denote values.\r\n\r\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\r\n  var _false = {keyword: \"false\", atomValue: false};\r\n\r\n  // Some keywords are treated as regular operators. `in` sometimes\r\n  // (when parsing `for`) needs to be tested against specifically, so\r\n  // we assign a variable name to it for quick comparing.\r\n\r\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\r\n\r\n  // Map keyword names to token types.\r\n\r\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\r\n                      \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\r\n                      \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\r\n                      \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\r\n                      \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\r\n                      \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\r\n                      \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\r\n                      \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\r\n                      \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\r\n                      \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\r\n\r\n  // Punctuation token types. Again, the `type` property is purely for debugging.\r\n\r\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\r\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\r\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\r\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\r\n\r\n  // Operators. These carry several kinds of properties to help the\r\n  // parser use them properly (the presence of these properties is\r\n  // what categorizes them as operators).\r\n  //\r\n  // `binop`, when present, specifies that this operator is a binary\r\n  // operator, and will refer to its precedence.\r\n  //\r\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\r\n  // unary operator. `isUpdate` specifies that the node produced by\r\n  // the operator should be of type UpdateExpression rather than\r\n  // simply UnaryExpression (`++` and `--`).\r\n  //\r\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\r\n  // binary operators with a very low precedence, that should result\r\n  // in AssignmentExpression nodes.\r\n\r\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\r\n  var _assign = {isAssign: true, beforeExpr: true};\r\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\r\n  var _logicalOR = {binop: 1, beforeExpr: true};\r\n  var _logicalAND = {binop: 2, beforeExpr: true};\r\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\r\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\r\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\r\n  var _equality = {binop: 6, beforeExpr: true};\r\n  var _relational = {binop: 7, beforeExpr: true};\r\n  var _bitShift = {binop: 8, beforeExpr: true};\r\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\r\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\r\n\r\n  // Provide access to the token types for external users of the\r\n  // tokenizer.\r\n\r\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\r\n                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\r\n                      dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\r\n                      num: _num, regexp: _regexp, string: _string};\r\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\r\n\r\n  // This is a trick taken from Esprima. It turns out that, on\r\n  // non-Chrome browsers, to check whether a string is in a set, a\r\n  // predicate containing a big ugly `switch` statement is faster than\r\n  // a regular expression, and on Chrome the two are about on par.\r\n  // This function uses `eval` (non-lexical) to produce such a\r\n  // predicate from a space-separated string of words.\r\n  //\r\n  // It starts by sorting the words by length.\r\n\r\n  function makePredicate(words) {\r\n    words = words.split(\" \");\r\n    var f = \"\", cats = [];\r\n    out: for (var i = 0; i < words.length; ++i) {\r\n      for (var j = 0; j < cats.length; ++j)\r\n        if (cats[j][0].length == words[i].length) {\r\n          cats[j].push(words[i]);\r\n          continue out;\r\n        }\r\n      cats.push([words[i]]);\r\n    }\r\n    function compareTo(arr) {\r\n      if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\r\n      f += \"switch(str){\";\r\n      for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\r\n      f += \"return true}return false;\";\r\n    }\r\n\r\n    // When there are more than three length categories, an outer\r\n    // switch first dispatches on the lengths, to save on comparisons.\r\n\r\n    if (cats.length > 3) {\r\n      cats.sort(function(a, b) {return b.length - a.length;});\r\n      f += \"switch(str.length){\";\r\n      for (var i = 0; i < cats.length; ++i) {\r\n        var cat = cats[i];\r\n        f += \"case \" + cat[0].length + \":\";\r\n        compareTo(cat);\r\n      }\r\n      f += \"}\";\r\n\r\n    // Otherwise, simply generate a flat `switch` statement.\r\n\r\n    } else {\r\n      compareTo(words);\r\n    }\r\n    return new Function(\"str\", f);\r\n  }\r\n\r\n  // The ECMAScript 3 reserved word list.\r\n\r\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\r\n\r\n  // ECMAScript 5 reserved words.\r\n\r\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\r\n\r\n  // The additional reserved words in strict mode.\r\n\r\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\r\n\r\n  // The forbidden variable names in strict mode.\r\n\r\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\r\n\r\n  // And the keywords.\r\n\r\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\r\n\r\n  // ## Character categories\r\n\r\n  // Big ugly regular expressions that match characters in the\r\n  // whitespace, identifier, and identifier-start categories. These\r\n  // are only applied when a character is found to actually have a\r\n  // code point above 128.\r\n\r\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\r\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\r\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\r\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\r\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\r\n\r\n  // Whether a single character denotes a newline.\r\n\r\n  var newline = /[\\n\\r\\u2028\\u2029]/;\r\n\r\n  // Matches a whole line break (where CRLF is considered a single\r\n  // line break). Used to count lines.\r\n\r\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\r\n\r\n  // Test whether a given character code starts an identifier.\r\n\r\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\r\n    if (code < 65) return code === 36;\r\n    if (code < 91) return true;\r\n    if (code < 97) return code === 95;\r\n    if (code < 123)return true;\r\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\r\n  };\r\n\r\n  // Test whether a given character is part of an identifier.\r\n\r\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\r\n    if (code < 48) return code === 36;\r\n    if (code < 58) return true;\r\n    if (code < 65) return false;\r\n    if (code < 91) return true;\r\n    if (code < 97) return code === 95;\r\n    if (code < 123)return true;\r\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\r\n  };\r\n\r\n  // ## Tokenizer\r\n\r\n  // These are used when `options.locations` is on, for the\r\n  // `tokStartLoc` and `tokEndLoc` properties.\r\n\r\n  function line_loc_t() {\r\n    this.line = tokCurLine;\r\n    this.column = tokPos - tokLineStart;\r\n  }\r\n\r\n  // Reset the token state. Used at the start of a parse.\r\n\r\n  function initTokenState() {\r\n    tokCurLine = 1;\r\n    tokPos = tokLineStart = 0;\r\n    tokRegexpAllowed = true;\r\n    skipSpace();\r\n  }\r\n\r\n  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and\r\n  // `tokRegexpAllowed`, and skips the space after the token, so that\r\n  // the next one's `tokStart` will point at the right position.\r\n\r\n  function finishToken(type, val) {\r\n    tokEnd = tokPos;\r\n    if (options.locations) tokEndLoc = new line_loc_t;\r\n    tokType = type;\r\n    skipSpace();\r\n    tokVal = val;\r\n    tokRegexpAllowed = type.beforeExpr;\r\n  }\r\n\r\n  function skipBlockComment() {\r\n    var startLoc = options.onComment && options.locations && new line_loc_t;\r\n    var start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\r\n    if (end === -1) raise(tokPos - 2, \"Unterminated comment\");\r\n    tokPos = end + 2;\r\n    if (options.locations) {\r\n      lineBreak.lastIndex = start;\r\n      var match;\r\n      while ((match = lineBreak.exec(input)) && match.index < tokPos) {\r\n        ++tokCurLine;\r\n        tokLineStart = match.index + match[0].length;\r\n      }\r\n    }\r\n    if (options.onComment)\r\n      options.onComment(true, input.slice(start + 2, end), start, tokPos,\r\n                        startLoc, options.locations && new line_loc_t);\r\n  }\r\n\r\n  function skipLineComment() {\r\n    var start = tokPos;\r\n    var startLoc = options.onComment && options.locations && new line_loc_t;\r\n    var ch = input.charCodeAt(tokPos+=2);\r\n    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\r\n      ++tokPos;\r\n      ch = input.charCodeAt(tokPos);\r\n    }\r\n    if (options.onComment)\r\n      options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\r\n                        startLoc, options.locations && new line_loc_t);\r\n  }\r\n\r\n  // Called at the start of the parse and after every token. Skips\r\n  // whitespace and comments, and.\r\n\r\n  function skipSpace() {\r\n    while (tokPos < inputLen) {\r\n      var ch = input.charCodeAt(tokPos);\r\n      if (ch === 32) { // ' '\r\n        ++tokPos;\r\n      } else if (ch === 13) {\r\n        ++tokPos;\r\n        var next = input.charCodeAt(tokPos);\r\n        if (next === 10) {\r\n          ++tokPos;\r\n        }\r\n        if (options.locations) {\r\n          ++tokCurLine;\r\n          tokLineStart = tokPos;\r\n        }\r\n      } else if (ch === 10 || ch === 8232 || ch === 8233) {\r\n        ++tokPos;\r\n        if (options.locations) {\r\n          ++tokCurLine;\r\n          tokLineStart = tokPos;\r\n        }\r\n      } else if (ch > 8 && ch < 14) {\r\n        ++tokPos;\r\n      } else if (ch === 47) { // '/'\r\n        var next = input.charCodeAt(tokPos + 1);\r\n        if (next === 42) { // '*'\r\n          skipBlockComment();\r\n        } else if (next === 47) { // '/'\r\n          skipLineComment();\r\n        } else break;\r\n      } else if (ch === 160) { // '\\xa0'\r\n        ++tokPos;\r\n      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\r\n        ++tokPos;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // ### Token reading\r\n\r\n  // This is the function that is called to fetch the next token. It\r\n  // is somewhat obscure, because it works in character codes rather\r\n  // than characters, and because operator parsing has been inlined\r\n  // into it.\r\n  //\r\n  // All in the name of speed.\r\n  //\r\n  // The `forceRegexp` parameter is used in the one case where the\r\n  // `tokRegexpAllowed` trick does not work. See `parseStatement`.\r\n\r\n  function readToken_dot() {\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next >= 48 && next <= 57) return readNumber(true);\r\n    ++tokPos;\r\n    return finishToken(_dot);\r\n  }\r\n\r\n  function readToken_slash() { // '/'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (tokRegexpAllowed) {++tokPos; return readRegexp();}\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(_slash, 1);\r\n  }\r\n\r\n  function readToken_mult_modulo() { // '%*'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(_multiplyModulo, 1);\r\n  }\r\n\r\n  function readToken_pipe_amp(code) { // '|&'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\r\n  }\r\n\r\n  function readToken_caret() { // '^'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(_bitwiseXOR, 1);\r\n  }\r\n\r\n  function readToken_plus_min(code) { // '+-'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === code) {\r\n      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\r\n          newline.test(input.slice(lastEnd, tokPos))) {\r\n        // A `-->` line comment\r\n        tokPos += 3;\r\n        skipLineComment();\r\n        skipSpace();\r\n        return readToken();\r\n      }\r\n      return finishOp(_incDec, 2);\r\n    }\r\n    if (next === 61) return finishOp(_assign, 2);\r\n    return finishOp(_plusMin, 1);\r\n  }\r\n\r\n  function readToken_lt_gt(code) { // '<>'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    var size = 1;\r\n    if (next === code) {\r\n      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\r\n      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\r\n      return finishOp(_bitShift, size);\r\n    }\r\n    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\r\n        input.charCodeAt(tokPos + 3) == 45) {\r\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\r\n      tokPos += 4;\r\n      skipLineComment();\r\n      skipSpace();\r\n      return readToken();\r\n    }\r\n    if (next === 61)\r\n      size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\r\n    return finishOp(_relational, size);\r\n  }\r\n\r\n  function readToken_eq_excl(code) { // '=!'\r\n    var next = input.charCodeAt(tokPos + 1);\r\n    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\r\n    return finishOp(code === 61 ? _eq : _prefix, 1);\r\n  }\r\n\r\n  function getTokenFromCode(code) {\r\n    switch(code) {\r\n      // The interpretation of a dot depends on whether it is followed\r\n      // by a digit.\r\n    case 46: // '.'\r\n      return readToken_dot();\r\n\r\n      // Punctuation tokens.\r\n    case 40: ++tokPos; return finishToken(_parenL);\r\n    case 41: ++tokPos; return finishToken(_parenR);\r\n    case 59: ++tokPos; return finishToken(_semi);\r\n    case 44: ++tokPos; return finishToken(_comma);\r\n    case 91: ++tokPos; return finishToken(_bracketL);\r\n    case 93: ++tokPos; return finishToken(_bracketR);\r\n    case 123: ++tokPos; return finishToken(_braceL);\r\n    case 125: ++tokPos; return finishToken(_braceR);\r\n    case 58: ++tokPos; return finishToken(_colon);\r\n    case 63: ++tokPos; return finishToken(_question);\r\n\r\n      // '0x' is a hexadecimal number.\r\n    case 48: // '0'\r\n      var next = input.charCodeAt(tokPos + 1);\r\n      if (next === 120 || next === 88) return readHexNumber();\r\n      // Anything else beginning with a digit is an integer, octal\r\n      // number, or float.\r\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\r\n      return readNumber(false);\r\n\r\n      // Quotes produce strings.\r\n    case 34: case 39: // '\"', \"'\"\r\n      return readString(code);\r\n\r\n    // Operators are parsed inline in tiny state machines. '=' (61) is\r\n    // often referred to. `finishOp` simply skips the amount of\r\n    // characters it is given as second argument, and returns a token\r\n    // of the type given by its first argument.\r\n\r\n    case 47: // '/'\r\n      return readToken_slash(code);\r\n\r\n    case 37: case 42: // '%*'\r\n      return readToken_mult_modulo();\r\n\r\n    case 124: case 38: // '|&'\r\n      return readToken_pipe_amp(code);\r\n\r\n    case 94: // '^'\r\n      return readToken_caret();\r\n\r\n    case 43: case 45: // '+-'\r\n      return readToken_plus_min(code);\r\n\r\n    case 60: case 62: // '<>'\r\n      return readToken_lt_gt(code);\r\n\r\n    case 61: case 33: // '=!'\r\n      return readToken_eq_excl(code);\r\n\r\n    case 126: // '~'\r\n      return finishOp(_prefix, 1);\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function readToken(forceRegexp) {\r\n    if (!forceRegexp) tokStart = tokPos;\r\n    else tokPos = tokStart + 1;\r\n    if (options.locations) tokStartLoc = new line_loc_t;\r\n    if (forceRegexp) return readRegexp();\r\n    if (tokPos >= inputLen) return finishToken(_eof);\r\n\r\n    var code = input.charCodeAt(tokPos);\r\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\r\n    // identifiers, so '\\' also dispatches to that.\r\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) return readWord();\r\n\r\n    var tok = getTokenFromCode(code);\r\n\r\n    if (tok === false) {\r\n      // If we are here, we either found a non-ASCII identifier\r\n      // character, or something that's entirely disallowed.\r\n      var ch = String.fromCharCode(code);\r\n      if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\r\n      raise(tokPos, \"Unexpected character '\" + ch + \"'\");\r\n    }\r\n    return tok;\r\n  }\r\n\r\n  function finishOp(type, size) {\r\n    var str = input.slice(tokPos, tokPos + size);\r\n    tokPos += size;\r\n    finishToken(type, str);\r\n  }\r\n\r\n  // Parse a regular expression. Some context-awareness is necessary,\r\n  // since a '/' inside a '[]' set does not end the expression.\r\n\r\n  function readRegexp() {\r\n    var content = \"\", escaped, inClass, start = tokPos;\r\n    for (;;) {\r\n      if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\r\n      var ch = input.charAt(tokPos);\r\n      if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\r\n      if (!escaped) {\r\n        if (ch === \"[\") inClass = true;\r\n        else if (ch === \"]\" && inClass) inClass = false;\r\n        else if (ch === \"/\" && !inClass) break;\r\n        escaped = ch === \"\\\\\";\r\n      } else escaped = false;\r\n      ++tokPos;\r\n    }\r\n    var content = input.slice(start, tokPos);\r\n    ++tokPos;\r\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\r\n    // here (don't ask).\r\n    var mods = readWord1();\r\n    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\r\n    return finishToken(_regexp, new RegExp(content, mods));\r\n  }\r\n\r\n  // Read an integer in the given radix. Return null if zero digits\r\n  // were read, the integer value otherwise. When `len` is given, this\r\n  // will return `null` unless the integer has exactly `len` digits.\r\n\r\n  function readInt(radix, len) {\r\n    var start = tokPos, total = 0;\r\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\r\n      var code = input.charCodeAt(tokPos), val;\r\n      if (code >= 97) val = code - 97 + 10; // a\r\n      else if (code >= 65) val = code - 65 + 10; // A\r\n      else if (code >= 48 && code <= 57) val = code - 48; // 0-9\r\n      else val = Infinity;\r\n      if (val >= radix) break;\r\n      ++tokPos;\r\n      total = total * radix + val;\r\n    }\r\n    if (tokPos === start || len != null && tokPos - start !== len) return null;\r\n\r\n    return total;\r\n  }\r\n\r\n  function readHexNumber() {\r\n    tokPos += 2; // 0x\r\n    var val = readInt(16);\r\n    if (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\r\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\r\n    return finishToken(_num, val);\r\n  }\r\n\r\n  // Read an integer, octal integer, or floating-point number.\r\n\r\n  function readNumber(startsWithDot) {\r\n    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\r\n    if (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\r\n    if (input.charCodeAt(tokPos) === 46) {\r\n      ++tokPos;\r\n      readInt(10);\r\n      isFloat = true;\r\n    }\r\n    var next = input.charCodeAt(tokPos);\r\n    if (next === 69 || next === 101) { // 'eE'\r\n      next = input.charCodeAt(++tokPos);\r\n      if (next === 43 || next === 45) ++tokPos; // '+-'\r\n      if (readInt(10) === null) raise(start, \"Invalid number\");\r\n      isFloat = true;\r\n    }\r\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\r\n\r\n    var str = input.slice(start, tokPos), val;\r\n    if (isFloat) val = parseFloat(str);\r\n    else if (!octal || str.length === 1) val = parseInt(str, 10);\r\n    else if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\r\n    else val = parseInt(str, 8);\r\n    return finishToken(_num, val);\r\n  }\r\n\r\n  // Read a string value, interpreting backslash-escapes.\r\n\r\n  function readString(quote) {\r\n    tokPos++;\r\n    var out = \"\";\r\n    for (;;) {\r\n      if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\r\n      var ch = input.charCodeAt(tokPos);\r\n      if (ch === quote) {\r\n        ++tokPos;\r\n        return finishToken(_string, out);\r\n      }\r\n      if (ch === 92) { // '\\'\r\n        ch = input.charCodeAt(++tokPos);\r\n        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\r\n        if (octal) octal = octal[0];\r\n        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\r\n        if (octal === \"0\") octal = null;\r\n        ++tokPos;\r\n        if (octal) {\r\n          if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\r\n          out += String.fromCharCode(parseInt(octal, 8));\r\n          tokPos += octal.length - 1;\r\n        } else {\r\n          switch (ch) {\r\n          case 110: out += \"\\n\"; break; // 'n' -> '\\n'\r\n          case 114: out += \"\\r\"; break; // 'r' -> '\\r'\r\n          case 120: out += String.fromCharCode(readHexChar(2)); break; // 'x'\r\n          case 117: out += String.fromCharCode(readHexChar(4)); break; // 'u'\r\n          case 85: out += String.fromCharCode(readHexChar(8)); break; // 'U'\r\n          case 116: out += \"\\t\"; break; // 't' -> '\\t'\r\n          case 98: out += \"\\b\"; break; // 'b' -> '\\b'\r\n          case 118: out += \"\\u000b\"; break; // 'v' -> '\\u000b'\r\n          case 102: out += \"\\f\"; break; // 'f' -> '\\f'\r\n          case 48: out += \"\\0\"; break; // 0 -> '\\0'\r\n          case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\\r\\n'\r\n          case 10: // ' \\n'\r\n            if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\r\n            break;\r\n          default: out += String.fromCharCode(ch); break;\r\n          }\r\n        }\r\n      } else {\r\n        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\r\n        out += String.fromCharCode(ch); // '\\'\r\n        ++tokPos;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\r\n\r\n  function readHexChar(len) {\r\n    var n = readInt(16, len);\r\n    if (n === null) raise(tokStart, \"Bad character escape sequence\");\r\n    return n;\r\n  }\r\n\r\n  // Used to signal to callers of `readWord1` whether the word\r\n  // contained any escape sequences. This is needed because words with\r\n  // escape sequences must not be interpreted as keywords.\r\n\r\n  var containsEsc;\r\n\r\n  // Read an identifier, and return it as a string. Sets `containsEsc`\r\n  // to whether the word contained a '\\u' escape.\r\n  //\r\n  // Only builds up the word character-by-character when it actually\r\n  // containeds an escape, as a micro-optimization.\r\n\r\n  function readWord1() {\r\n    containsEsc = false;\r\n    var word, first = true, start = tokPos;\r\n    for (;;) {\r\n      var ch = input.charCodeAt(tokPos);\r\n      if (isIdentifierChar(ch)) {\r\n        if (containsEsc) word += input.charAt(tokPos);\r\n        ++tokPos;\r\n      } else if (ch === 92) { // \"\\\"\r\n        if (!containsEsc) word = input.slice(start, tokPos);\r\n        containsEsc = true;\r\n        if (input.charCodeAt(++tokPos) != 117) // \"u\"\r\n          raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\r\n        ++tokPos;\r\n        var esc = readHexChar(4);\r\n        var escStr = String.fromCharCode(esc);\r\n        if (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\r\n        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\r\n          raise(tokPos - 4, \"Invalid Unicode escape\");\r\n        word += escStr;\r\n      } else {\r\n        break;\r\n      }\r\n      first = false;\r\n    }\r\n    return containsEsc ? word : input.slice(start, tokPos);\r\n  }\r\n\r\n  // Read an identifier or keyword token. Will check for reserved\r\n  // words when necessary.\r\n\r\n  function readWord() {\r\n    var word = readWord1();\r\n    var type = _name;\r\n    if (!containsEsc) {\r\n      if (isKeyword(word)) type = keywordTypes[word];\r\n      else if (options.forbidReserved &&\r\n               (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) ||\r\n               strict && isStrictReservedWord(word))\r\n        raise(tokStart, \"The keyword '\" + word + \"' is reserved\");\r\n    }\r\n    return finishToken(type, word);\r\n  }\r\n\r\n  // ## Parser\r\n\r\n  // A recursive descent parser operates by defining functions for all\r\n  // syntactic elements, and recursively calling those, each function\r\n  // advancing the input stream and returning an AST node. Precedence\r\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\r\n  // instead of `(!x)[1]` is handled by the fact that the parser\r\n  // function that parses unary prefix operators is called first, and\r\n  // in turn calls the function that parses `[]` subscripts — that\r\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\r\n  // *that* in the unary operator node.\r\n  //\r\n  // Acorn uses an [operator precedence parser][opp] to handle binary\r\n  // operator precedence, because it is much more compact than using\r\n  // the technique outlined above, which uses different, nesting\r\n  // functions to specify precedence, for all of the ten binary\r\n  // precedence levels that JavaScript defines.\r\n  //\r\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\r\n\r\n  // ### Parser utilities\r\n\r\n  // Continue to the next token.\r\n\r\n  function next() {\r\n    lastStart = tokStart;\r\n    lastEnd = tokEnd;\r\n    lastEndLoc = tokEndLoc;\r\n    readToken();\r\n  }\r\n\r\n  // Enter strict mode. Re-reads the next token to please pedantic\r\n  // tests (\"use strict\"; 010; -- should fail).\r\n\r\n  function setStrict(strct) {\r\n    strict = strct;\r\n    tokPos = lastEnd;\r\n    if (options.locations) {\r\n      while (tokPos < tokLineStart) {\r\n        tokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\r\n        --tokCurLine;\r\n      }\r\n    }\r\n    skipSpace();\r\n    readToken();\r\n  }\r\n\r\n  // Start an AST node, attaching a start offset.\r\n\r\n  function node_t() {\r\n    this.type = null;\r\n    this.start = tokStart;\r\n    this.end = null;\r\n  }\r\n\r\n  function node_loc_t() {\r\n    this.start = tokStartLoc;\r\n    this.end = null;\r\n    if (sourceFile !== null) this.source = sourceFile;\r\n  }\r\n\r\n  function startNode() {\r\n    var node = new node_t();\r\n    if (options.locations)\r\n      node.loc = new node_loc_t();\r\n    if (options.directSourceFile)\r\n      node.sourceFile = options.directSourceFile;\r\n    if (options.ranges)\r\n      node.range = [tokStart, 0];\r\n    return node;\r\n  }\r\n\r\n  // Start a node whose start offset information should be based on\r\n  // the start of another node. For example, a binary operator node is\r\n  // only started after its left-hand side has already been parsed.\r\n\r\n  function startNodeFrom(other) {\r\n    var node = new node_t();\r\n    node.start = other.start;\r\n    if (options.locations) {\r\n      node.loc = new node_loc_t();\r\n      node.loc.start = other.loc.start;\r\n    }\r\n    if (options.ranges)\r\n      node.range = [other.range[0], 0];\r\n\r\n    return node;\r\n  }\r\n\r\n  // Finish an AST node, adding `type` and `end` properties.\r\n\r\n  function finishNode(node, type) {\r\n    node.type = type;\r\n    node.end = lastEnd;\r\n    if (options.locations)\r\n      node.loc.end = lastEndLoc;\r\n    if (options.ranges)\r\n      node.range[1] = lastEnd;\r\n    return node;\r\n  }\r\n\r\n  // Test whether a statement node is the string literal `\"use strict\"`.\r\n\r\n  function isUseStrict(stmt) {\r\n    return options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\r\n      stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\r\n  }\r\n\r\n  // Predicate that tests whether the next token is of the given\r\n  // type, and if yes, consumes it as a side effect.\r\n\r\n  function eat(type) {\r\n    if (tokType === type) {\r\n      next();\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // Test whether a semicolon can be inserted at the current position.\r\n\r\n  function canInsertSemicolon() {\r\n    return !options.strictSemicolons &&\r\n      (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\r\n  }\r\n\r\n  // Consume a semicolon, or, failing that, see if we are allowed to\r\n  // pretend that there is a semicolon at this position.\r\n\r\n  function semicolon() {\r\n    if (!eat(_semi) && !canInsertSemicolon()) unexpected();\r\n  }\r\n\r\n  // Expect a token of a given type. If found, consume it, otherwise,\r\n  // raise an unexpected token error.\r\n\r\n  function expect(type) {\r\n    if (tokType === type) next();\r\n    else unexpected();\r\n  }\r\n\r\n  // Raise an unexpected token error.\r\n\r\n  function unexpected() {\r\n    raise(tokStart, \"Unexpected token\");\r\n  }\r\n\r\n  // Verify that a node is an lval — something that can be assigned\r\n  // to.\r\n\r\n  function checkLVal(expr) {\r\n    if (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\r\n      raise(expr.start, \"Assigning to rvalue\");\r\n    if (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\r\n      raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\r\n  }\r\n\r\n  // ### Statement parsing\r\n\r\n  // Parse a program. Initializes the parser, reads any number of\r\n  // statements, and wraps them in a Program node.  Optionally takes a\r\n  // `program` argument.  If present, the statements will be appended\r\n  // to its body instead of creating a new node.\r\n\r\n  function parseTopLevel(program) {\r\n    lastStart = lastEnd = tokPos;\r\n    if (options.locations) lastEndLoc = new line_loc_t;\r\n    inFunction = strict = null;\r\n    labels = [];\r\n    readToken();\r\n\r\n    var node = program || startNode(), first = true;\r\n    if (!program) node.body = [];\r\n    while (tokType !== _eof) {\r\n      var stmt = parseStatement();\r\n      node.body.push(stmt);\r\n      if (first && isUseStrict(stmt)) setStrict(true);\r\n      first = false;\r\n    }\r\n    return finishNode(node, \"Program\");\r\n  }\r\n\r\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\r\n\r\n  // Parse a single statement.\r\n  //\r\n  // If expecting a statement and finding a slash operator, parse a\r\n  // regular expression literal. This is to handle cases like\r\n  // `if (foo) /blah/.exec(foo);`, where looking at the previous token\r\n  // does not help.\r\n\r\n  function parseStatement() {\r\n    if (tokType === _slash || tokType === _assign && tokVal == \"/=\")\r\n      readToken(true);\r\n\r\n    var starttype = tokType, node = startNode();\r\n\r\n    // Most types of statements are recognized by the keyword they\r\n    // start with. Many are trivial to parse, some require a bit of\r\n    // complexity.\r\n\r\n    switch (starttype) {\r\n    case _break: case _continue:\r\n      next();\r\n      var isBreak = starttype === _break;\r\n      if (eat(_semi) || canInsertSemicolon()) node.label = null;\r\n      else if (tokType !== _name) unexpected();\r\n      else {\r\n        node.label = parseIdent();\r\n        semicolon();\r\n      }\r\n\r\n      // Verify that there is an actual destination to break or\r\n      // continue to.\r\n      for (var i = 0; i < labels.length; ++i) {\r\n        var lab = labels[i];\r\n        if (node.label == null || lab.name === node.label.name) {\r\n          if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\r\n          if (node.label && isBreak) break;\r\n        }\r\n      }\r\n      if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\r\n      return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\r\n\r\n    case _debugger:\r\n      next();\r\n      semicolon();\r\n      return finishNode(node, \"DebuggerStatement\");\r\n\r\n    case _do:\r\n      next();\r\n      labels.push(loopLabel);\r\n      node.body = parseStatement();\r\n      labels.pop();\r\n      expect(_while);\r\n      node.test = parseParenExpression();\r\n      semicolon();\r\n      return finishNode(node, \"DoWhileStatement\");\r\n\r\n      // Disambiguating between a `for` and a `for`/`in` loop is\r\n      // non-trivial. Basically, we have to parse the init `var`\r\n      // statement or expression, disallowing the `in` operator (see\r\n      // the second parameter to `parseExpression`), and then check\r\n      // whether the next token is `in`. When there is no init part\r\n      // (semicolon immediately after the opening parenthesis), it is\r\n      // a regular `for` loop.\r\n\r\n    case _for:\r\n      next();\r\n      labels.push(loopLabel);\r\n      expect(_parenL);\r\n      if (tokType === _semi) return parseFor(node, null);\r\n      if (tokType === _var) {\r\n        var init = startNode();\r\n        next();\r\n        parseVar(init, true);\r\n        finishNode(init, \"VariableDeclaration\");\r\n        if (init.declarations.length === 1 && eat(_in))\r\n          return parseForIn(node, init);\r\n        return parseFor(node, init);\r\n      }\r\n      var init = parseExpression(false, true);\r\n      if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\r\n      return parseFor(node, init);\r\n\r\n    case _function:\r\n      next();\r\n      return parseFunction(node, true);\r\n\r\n    case _if:\r\n      next();\r\n      node.test = parseParenExpression();\r\n      node.consequent = parseStatement();\r\n      node.alternate = eat(_else) ? parseStatement() : null;\r\n      return finishNode(node, \"IfStatement\");\r\n\r\n    case _return:\r\n      if (!inFunction) raise(tokStart, \"'return' outside of function\");\r\n      next();\r\n\r\n      // In `return` (and `break`/`continue`), the keywords with\r\n      // optional arguments, we eagerly look for a semicolon or the\r\n      // possibility to insert one.\r\n\r\n      if (eat(_semi) || canInsertSemicolon()) node.argument = null;\r\n      else { node.argument = parseExpression(); semicolon(); }\r\n      return finishNode(node, \"ReturnStatement\");\r\n\r\n    case _switch:\r\n      next();\r\n      node.discriminant = parseParenExpression();\r\n      node.cases = [];\r\n      expect(_braceL);\r\n      labels.push(switchLabel);\r\n\r\n      // Statements under must be grouped (by label) in SwitchCase\r\n      // nodes. `cur` is used to keep the node that we are currently\r\n      // adding statements to.\r\n\r\n      for (var cur, sawDefault; tokType != _braceR;) {\r\n        if (tokType === _case || tokType === _default) {\r\n          var isCase = tokType === _case;\r\n          if (cur) finishNode(cur, \"SwitchCase\");\r\n          node.cases.push(cur = startNode());\r\n          cur.consequent = [];\r\n          next();\r\n          if (isCase) cur.test = parseExpression();\r\n          else {\r\n            if (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\r\n            cur.test = null;\r\n          }\r\n          expect(_colon);\r\n        } else {\r\n          if (!cur) unexpected();\r\n          cur.consequent.push(parseStatement());\r\n        }\r\n      }\r\n      if (cur) finishNode(cur, \"SwitchCase\");\r\n      next(); // Closing brace\r\n      labels.pop();\r\n      return finishNode(node, \"SwitchStatement\");\r\n\r\n    case _throw:\r\n      next();\r\n      if (newline.test(input.slice(lastEnd, tokStart)))\r\n        raise(lastEnd, \"Illegal newline after throw\");\r\n      node.argument = parseExpression();\r\n      semicolon();\r\n      return finishNode(node, \"ThrowStatement\");\r\n\r\n    case _try:\r\n      next();\r\n      node.block = parseBlock();\r\n      node.handler = null;\r\n      if (tokType === _catch) {\r\n        var clause = startNode();\r\n        next();\r\n        expect(_parenL);\r\n        clause.param = parseIdent();\r\n        if (strict && isStrictBadIdWord(clause.param.name))\r\n          raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\r\n        expect(_parenR);\r\n        clause.guard = null;\r\n        clause.body = parseBlock();\r\n        node.handler = finishNode(clause, \"CatchClause\");\r\n      }\r\n      node.guardedHandlers = empty;\r\n      node.finalizer = eat(_finally) ? parseBlock() : null;\r\n      if (!node.handler && !node.finalizer)\r\n        raise(node.start, \"Missing catch or finally clause\");\r\n      return finishNode(node, \"TryStatement\");\r\n\r\n    case _var:\r\n      next();\r\n      parseVar(node);\r\n      semicolon();\r\n      return finishNode(node, \"VariableDeclaration\");\r\n\r\n    case _while:\r\n      next();\r\n      node.test = parseParenExpression();\r\n      labels.push(loopLabel);\r\n      node.body = parseStatement();\r\n      labels.pop();\r\n      return finishNode(node, \"WhileStatement\");\r\n\r\n    case _with:\r\n      if (strict) raise(tokStart, \"'with' in strict mode\");\r\n      next();\r\n      node.object = parseParenExpression();\r\n      node.body = parseStatement();\r\n      return finishNode(node, \"WithStatement\");\r\n\r\n    case _braceL:\r\n      return parseBlock();\r\n\r\n    case _semi:\r\n      next();\r\n      return finishNode(node, \"EmptyStatement\");\r\n\r\n      // If the statement does not start with a statement keyword or a\r\n      // brace, it's an ExpressionStatement or LabeledStatement. We\r\n      // simply start parsing an expression, and afterwards, if the\r\n      // next token is a colon and the expression was a simple\r\n      // Identifier node, we switch to interpreting it as a label.\r\n\r\n    default:\r\n      var maybeName = tokVal, expr = parseExpression();\r\n      if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\r\n        for (var i = 0; i < labels.length; ++i)\r\n          if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\r\n        var kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\r\n        labels.push({name: maybeName, kind: kind});\r\n        node.body = parseStatement();\r\n        labels.pop();\r\n        node.label = expr;\r\n        return finishNode(node, \"LabeledStatement\");\r\n      } else {\r\n        node.expression = expr;\r\n        semicolon();\r\n        return finishNode(node, \"ExpressionStatement\");\r\n      }\r\n    }\r\n  }\r\n\r\n  // Used for constructs like `switch` and `if` that insist on\r\n  // parentheses around their expression.\r\n\r\n  function parseParenExpression() {\r\n    expect(_parenL);\r\n    var val = parseExpression();\r\n    expect(_parenR);\r\n    return val;\r\n  }\r\n\r\n  // Parse a semicolon-enclosed block of statements, handling `\"use\r\n  // strict\"` declarations when `allowStrict` is true (used for\r\n  // function bodies).\r\n\r\n  function parseBlock(allowStrict) {\r\n    var node = startNode(), first = true, strict = false, oldStrict;\r\n    node.body = [];\r\n    expect(_braceL);\r\n    while (!eat(_braceR)) {\r\n      var stmt = parseStatement();\r\n      node.body.push(stmt);\r\n      if (first && allowStrict && isUseStrict(stmt)) {\r\n        oldStrict = strict;\r\n        setStrict(strict = true);\r\n      }\r\n      first = false;\r\n    }\r\n    if (strict && !oldStrict) setStrict(false);\r\n    return finishNode(node, \"BlockStatement\");\r\n  }\r\n\r\n  // Parse a regular `for` loop. The disambiguation code in\r\n  // `parseStatement` will already have parsed the init statement or\r\n  // expression.\r\n\r\n  function parseFor(node, init) {\r\n    node.init = init;\r\n    expect(_semi);\r\n    node.test = tokType === _semi ? null : parseExpression();\r\n    expect(_semi);\r\n    node.update = tokType === _parenR ? null : parseExpression();\r\n    expect(_parenR);\r\n    node.body = parseStatement();\r\n    labels.pop();\r\n    return finishNode(node, \"ForStatement\");\r\n  }\r\n\r\n  // Parse a `for`/`in` loop.\r\n\r\n  function parseForIn(node, init) {\r\n    node.left = init;\r\n    node.right = parseExpression();\r\n    expect(_parenR);\r\n    node.body = parseStatement();\r\n    labels.pop();\r\n    return finishNode(node, \"ForInStatement\");\r\n  }\r\n\r\n  // Parse a list of variable declarations.\r\n\r\n  function parseVar(node, noIn) {\r\n    node.declarations = [];\r\n    node.kind = \"var\";\r\n    for (;;) {\r\n      var decl = startNode();\r\n      decl.id = parseIdent();\r\n      if (strict && isStrictBadIdWord(decl.id.name))\r\n        raise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\r\n      decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\r\n      node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\r\n      if (!eat(_comma)) break;\r\n    }\r\n    return node;\r\n  }\r\n\r\n  // ### Expression parsing\r\n\r\n  // These nest, from the most general expression type at the top to\r\n  // 'atomic', nondivisible expression types at the bottom. Most of\r\n  // the functions will simply let the function(s) below them parse,\r\n  // and, *if* the syntactic construct they handle is present, wrap\r\n  // the AST node that the inner parser gave them in another node.\r\n\r\n  // Parse a full expression. The arguments are used to forbid comma\r\n  // sequences (in argument lists, array literals, or object literals)\r\n  // or the `in` operator (in for loops initalization expressions).\r\n\r\n  function parseExpression(noComma, noIn) {\r\n    var expr = parseMaybeAssign(noIn);\r\n    if (!noComma && tokType === _comma) {\r\n      var node = startNodeFrom(expr);\r\n      node.expressions = [expr];\r\n      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\r\n      return finishNode(node, \"SequenceExpression\");\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // Parse an assignment expression. This includes applications of\r\n  // operators like `+=`.\r\n\r\n  function parseMaybeAssign(noIn) {\r\n    var left = parseMaybeConditional(noIn);\r\n    if (tokType.isAssign) {\r\n      var node = startNodeFrom(left);\r\n      node.operator = tokVal;\r\n      node.left = left;\r\n      next();\r\n      node.right = parseMaybeAssign(noIn);\r\n      checkLVal(left);\r\n      return finishNode(node, \"AssignmentExpression\");\r\n    }\r\n    return left;\r\n  }\r\n\r\n  // Parse a ternary conditional (`?:`) operator.\r\n\r\n  function parseMaybeConditional(noIn) {\r\n    var expr = parseExprOps(noIn);\r\n    if (eat(_question)) {\r\n      var node = startNodeFrom(expr);\r\n      node.test = expr;\r\n      node.consequent = parseExpression(true);\r\n      expect(_colon);\r\n      node.alternate = parseExpression(true, noIn);\r\n      return finishNode(node, \"ConditionalExpression\");\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // Start the precedence parser.\r\n\r\n  function parseExprOps(noIn) {\r\n    return parseExprOp(parseMaybeUnary(), -1, noIn);\r\n  }\r\n\r\n  // Parse binary operators with the operator precedence parsing\r\n  // algorithm. `left` is the left-hand side of the operator.\r\n  // `minPrec` provides context that allows the function to stop and\r\n  // defer further parser to one of its callers when it encounters an\r\n  // operator that has a lower precedence than the set it is parsing.\r\n\r\n  function parseExprOp(left, minPrec, noIn) {\r\n    var prec = tokType.binop;\r\n    if (prec != null && (!noIn || tokType !== _in)) {\r\n      if (prec > minPrec) {\r\n        var node = startNodeFrom(left);\r\n        node.left = left;\r\n        node.operator = tokVal;\r\n        var op = tokType;\r\n        next();\r\n        node.right = parseExprOp(parseMaybeUnary(), prec, noIn);\r\n        var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\r\n        return parseExprOp(exprNode, minPrec, noIn);\r\n      }\r\n    }\r\n    return left;\r\n  }\r\n\r\n  // Parse unary operators, both prefix and postfix.\r\n\r\n  function parseMaybeUnary() {\r\n    if (tokType.prefix) {\r\n      var node = startNode(), update = tokType.isUpdate;\r\n      node.operator = tokVal;\r\n      node.prefix = true;\r\n      tokRegexpAllowed = true;\r\n      next();\r\n      node.argument = parseMaybeUnary();\r\n      if (update) checkLVal(node.argument);\r\n      else if (strict && node.operator === \"delete\" &&\r\n               node.argument.type === \"Identifier\")\r\n        raise(node.start, \"Deleting local variable in strict mode\");\r\n      return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\r\n    }\r\n    var expr = parseExprSubscripts();\r\n    while (tokType.postfix && !canInsertSemicolon()) {\r\n      var node = startNodeFrom(expr);\r\n      node.operator = tokVal;\r\n      node.prefix = false;\r\n      node.argument = expr;\r\n      checkLVal(expr);\r\n      next();\r\n      expr = finishNode(node, \"UpdateExpression\");\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // Parse call, dot, and `[]`-subscript expressions.\r\n\r\n  function parseExprSubscripts() {\r\n    return parseSubscripts(parseExprAtom());\r\n  }\r\n\r\n  function parseSubscripts(base, noCalls) {\r\n    if (eat(_dot)) {\r\n      var node = startNodeFrom(base);\r\n      node.object = base;\r\n      node.property = parseIdent(true);\r\n      node.computed = false;\r\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\r\n    } else if (eat(_bracketL)) {\r\n      var node = startNodeFrom(base);\r\n      node.object = base;\r\n      node.property = parseExpression();\r\n      node.computed = true;\r\n      expect(_bracketR);\r\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\r\n    } else if (!noCalls && eat(_parenL)) {\r\n      var node = startNodeFrom(base);\r\n      node.callee = base;\r\n      node.arguments = parseExprList(_parenR, false);\r\n      return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\r\n    } else return base;\r\n  }\r\n\r\n  // Parse an atomic expression — either a single token that is an\r\n  // expression, an expression started by a keyword like `function` or\r\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\r\n  // or `{}`.\r\n\r\n  function parseExprAtom() {\r\n    switch (tokType) {\r\n    case _this:\r\n      var node = startNode();\r\n      next();\r\n      return finishNode(node, \"ThisExpression\");\r\n    case _name:\r\n      return parseIdent();\r\n    case _num: case _string: case _regexp:\r\n      var node = startNode();\r\n      node.value = tokVal;\r\n      node.raw = input.slice(tokStart, tokEnd);\r\n      next();\r\n      return finishNode(node, \"Literal\");\r\n\r\n    case _null: case _true: case _false:\r\n      var node = startNode();\r\n      node.value = tokType.atomValue;\r\n      node.raw = tokType.keyword;\r\n      next();\r\n      return finishNode(node, \"Literal\");\r\n\r\n    case _parenL:\r\n      var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\r\n      next();\r\n      var val = parseExpression();\r\n      val.start = tokStart1;\r\n      val.end = tokEnd;\r\n      if (options.locations) {\r\n        val.loc.start = tokStartLoc1;\r\n        val.loc.end = tokEndLoc;\r\n      }\r\n      if (options.ranges)\r\n        val.range = [tokStart1, tokEnd];\r\n      expect(_parenR);\r\n      return val;\r\n\r\n    case _bracketL:\r\n      var node = startNode();\r\n      next();\r\n      node.elements = parseExprList(_bracketR, true, true);\r\n      return finishNode(node, \"ArrayExpression\");\r\n\r\n    case _braceL:\r\n      return parseObj();\r\n\r\n    case _function:\r\n      var node = startNode();\r\n      next();\r\n      return parseFunction(node, false);\r\n\r\n    case _new:\r\n      return parseNew();\r\n\r\n    default:\r\n      unexpected();\r\n    }\r\n  }\r\n\r\n  // New's precedence is slightly tricky. It must allow its argument\r\n  // to be a `[]` or dot subscript expression, but not a call — at\r\n  // least, not without wrapping it in parentheses. Thus, it uses the\r\n\r\n  function parseNew() {\r\n    var node = startNode();\r\n    next();\r\n    node.callee = parseSubscripts(parseExprAtom(), true);\r\n    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\r\n    else node.arguments = empty;\r\n    return finishNode(node, \"NewExpression\");\r\n  }\r\n\r\n  // Parse an object literal.\r\n\r\n  function parseObj() {\r\n    var node = startNode(), first = true, sawGetSet = false;\r\n    node.properties = [];\r\n    next();\r\n    while (!eat(_braceR)) {\r\n      if (!first) {\r\n        expect(_comma);\r\n        if (options.allowTrailingCommas && eat(_braceR)) break;\r\n      } else first = false;\r\n\r\n      var prop = {key: parsePropertyName()}, isGetSet = false, kind;\r\n      if (eat(_colon)) {\r\n        prop.value = parseExpression(true);\r\n        kind = prop.kind = \"init\";\r\n      } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\r\n                 (prop.key.name === \"get\" || prop.key.name === \"set\")) {\r\n        isGetSet = sawGetSet = true;\r\n        kind = prop.kind = prop.key.name;\r\n        prop.key = parsePropertyName();\r\n        if (tokType !== _parenL) unexpected();\r\n        prop.value = parseFunction(startNode(), false);\r\n      } else unexpected();\r\n\r\n      // getters and setters are not allowed to clash — either with\r\n      // each other or with an init property — and in strict mode,\r\n      // init properties are also not allowed to be repeated.\r\n\r\n      if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\r\n        for (var i = 0; i < node.properties.length; ++i) {\r\n          var other = node.properties[i];\r\n          if (other.key.name === prop.key.name) {\r\n            var conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\r\n              kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\r\n            if (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\r\n            if (conflict) raise(prop.key.start, \"Redefinition of property\");\r\n          }\r\n        }\r\n      }\r\n      node.properties.push(prop);\r\n    }\r\n    return finishNode(node, \"ObjectExpression\");\r\n  }\r\n\r\n  function parsePropertyName() {\r\n    if (tokType === _num || tokType === _string) return parseExprAtom();\r\n    return parseIdent(true);\r\n  }\r\n\r\n  // Parse a function declaration or literal (depending on the\r\n  // `isStatement` parameter).\r\n\r\n  function parseFunction(node, isStatement) {\r\n    if (tokType === _name) node.id = parseIdent();\r\n    else if (isStatement) unexpected();\r\n    else node.id = null;\r\n    node.params = [];\r\n    var first = true;\r\n    expect(_parenL);\r\n    while (!eat(_parenR)) {\r\n      if (!first) expect(_comma); else first = false;\r\n      node.params.push(parseIdent());\r\n    }\r\n\r\n    // Start a new scope with regard to labels and the `inFunction`\r\n    // flag (restore them to their old value afterwards).\r\n    var oldInFunc = inFunction, oldLabels = labels;\r\n    inFunction = true; labels = [];\r\n    node.body = parseBlock(true);\r\n    inFunction = oldInFunc; labels = oldLabels;\r\n\r\n    // If this is a strict mode function, verify that argument names\r\n    // are not repeated, and it does not try to bind the words `eval`\r\n    // or `arguments`.\r\n    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\r\n      for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\r\n        var id = i < 0 ? node.id : node.params[i];\r\n        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\r\n          raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\r\n        if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\r\n          raise(id.start, \"Argument name clash in strict mode\");\r\n      }\r\n    }\r\n\r\n    return finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\r\n  }\r\n\r\n  // Parses a comma-separated list of expressions, and returns them as\r\n  // an array. `close` is the token type that ends the list, and\r\n  // `allowEmpty` can be turned on to allow subsequent commas with\r\n  // nothing in between them to be parsed as `null` (which is needed\r\n  // for array literals).\r\n\r\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\r\n    var elts = [], first = true;\r\n    while (!eat(close)) {\r\n      if (!first) {\r\n        expect(_comma);\r\n        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\r\n      } else first = false;\r\n\r\n      if (allowEmpty && tokType === _comma) elts.push(null);\r\n      else elts.push(parseExpression(true));\r\n    }\r\n    return elts;\r\n  }\r\n\r\n  // Parse the next token as an identifier. If `liberal` is true (used\r\n  // when parsing properties), it will also convert keywords into\r\n  // identifiers.\r\n\r\n  function parseIdent(liberal) {\r\n    var node = startNode();\r\n    node.name = tokType === _name ? tokVal : (liberal && !options.forbidReserved && tokType.keyword) || unexpected();\r\n    tokRegexpAllowed = false;\r\n    next();\r\n    return finishNode(node, \"Identifier\");\r\n  }\r\n\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./acorn.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 3\n// module chunks = 0","/// <reference types=\"node\" />\r\n\r\nimport * as i from './interpreter';\r\n(this.self || global)[\"Interpreter\"] = i;\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib/global.ts","/// <reference path=\"./_estree.d.ts\" />\r\n\r\n// Declare missing functions\r\ndeclare function escape(s:string): string;\r\ndeclare function unescape(s:string): string;\r\ndeclare module acorn {\r\n  function parse(code: string, options?: any): ESTree.Program;\r\n}\r\ninterface NodeConstructor {\r\n  new (): ESTree.BaseNode;\r\n}\r\ninterface NativeFunction extends Function {\r\n  id?: number;\r\n}\r\n\r\n// Import acorn if not found\r\nif (typeof acorn === 'undefined') {\r\n  (this.self || global)['acorn'] = require('acorn');\r\n}\r\n\r\n/**\r\n * @license\r\n * JavaScript Interpreter\r\n *\r\n * Copyright 2013 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @fileoverview Interpreting JavaScript in JavaScript.\r\n * @author fraser@google.com (Neil Fraser)\r\n */\r\n\r\n/**\r\n * Create a new interpreter.\r\n * @param {string|!Object} code Raw JavaScript text or AST.\r\n * @param {Function=} opt_initFunc Optional initialization function.  Used to\r\n *     define APIs.  When called it is passed the interpreter object and the\r\n *     global scope object.\r\n * @constructor\r\n */\r\nclass Interpreter {\r\nprivate nodeConstructor: NodeConstructor;\r\npublic ast: ESTree.Program;\r\npublic global: Interpreter.MyObject;\r\npublic stateStack: Interpreter.MyState[];\r\npublic value: Interpreter.MyValue;\r\nprivate initFunc_: (i: Interpreter, scope: Interpreter.MyObject) => void;\r\nprivate paused_: boolean;\r\nprivate polyfills_: string[];\r\nprivate functionCounter_: number;\r\nprivate stepFunctions_: { [key: string]: Function };\r\n\r\npublic OBJECT: Interpreter.MyObject;\r\npublic OBJECT_PROTO: Interpreter.MyObject;\r\npublic FUNCTION: Interpreter.MyObject;\r\npublic FUNCTION_PROTO: Interpreter.MyObject;\r\npublic ARRAY: Interpreter.MyObject;\r\npublic ARRAY_PROTO: Interpreter.MyObject;\r\npublic REGEXP: Interpreter.MyObject;\r\npublic REGEXP_PROTO: Interpreter.MyObject;\r\n\r\npublic ERROR: Interpreter.MyObject;\r\npublic EVAL_ERROR: Interpreter.MyObject;\r\npublic RANGE_ERROR: Interpreter.MyObject;\r\npublic REFERENCE_ERROR: Interpreter.MyObject;\r\npublic SYNTAX_ERROR: Interpreter.MyObject;\r\npublic TYPE_ERROR: Interpreter.MyObject;\r\npublic URI_ERROR: Interpreter.MyObject;\r\n\r\npublic STRING: Interpreter.MyObject;\r\npublic BOOLEAN: Interpreter.MyObject;\r\npublic NUMBER: Interpreter.MyObject;\r\npublic DATE: Interpreter.MyObject;\r\n\r\n// The following properties are obsolete.  Do not use.\r\npublic UNDEFINED: Interpreter.MyObject;\r\npublic NULL: null;\r\npublic NAN: number;\r\npublic TRUE: boolean;\r\npublic FALSE: boolean;\r\npublic STRING_EMPTY: string;\r\npublic NUMBER_ZERO: number;\r\npublic NUMBER_ONE: number;\r\n\r\nconstructor(code: string | ESTree.Program\r\n    , opt_initFunc?: (i: Interpreter, scope: Interpreter.MyObject) => void) {\r\n  if (typeof code === 'string') {\r\n    code = acorn.parse(code, Interpreter.PARSE_OPTIONS);\r\n  }\r\n  this.ast = code;\r\n  this.initFunc_ = opt_initFunc;\r\n  this.paused_ = false;\r\n  this.polyfills_ = [];\r\n  // Unique identifier for native functions.  Used in serialization.\r\n  this.functionCounter_ = 0;\r\n  // Map node types to our step function names; a property lookup is faster\r\n  // than string concatenation with \"step\" prefix.\r\n  this.stepFunctions_ = Object.create(null);\r\n  var stepMatch = /^step([A-Z]\\w*)$/;\r\n  var m;\r\n  for (var methodName in this) {\r\n    if ((typeof this[methodName] === 'function') &&\r\n        (m = methodName.match(stepMatch))) {\r\n      this.stepFunctions_[m[1]] = (<Function>this[methodName]).bind(this);\r\n    }\r\n  }\r\n  // Create and initialize the global scope.\r\n  this.global = this.createScope(this.ast, null);\r\n  // Run the polyfills.\r\n  this.ast = acorn.parse(this.polyfills_.join('\\n'), Interpreter.PARSE_OPTIONS);\r\n  this.polyfills_ = undefined;  // Allow polyfill strings to garbage collect.\r\n  this.stripLocations_(this.ast, undefined, undefined);\r\n  var state = new Interpreter.MyState(this.ast, this.global);\r\n  state.done = false;\r\n  this.stateStack = [state];\r\n  this.run();\r\n  this.value = undefined;\r\n  // Point at the main program.\r\n  this.ast = code;\r\n  var state = new Interpreter.MyState(this.ast, this.global);\r\n  state.done = false;\r\n  this.stateStack.length = 0;\r\n  this.stateStack[0] = state;\r\n  // Get a handle on Acorn's node_t object.  It's tricky to access.\r\n  this.nodeConstructor = <NodeConstructor>state.node.constructor;\r\n  // Preserve publicly properties from being pruned/renamed by JS compilers.\r\n  // Add others as needed.\r\n  this['stateStack'] = this.stateStack;\r\n  this['OBJECT'] = this.OBJECT; this['OBJECT_PROTO'] = this.OBJECT_PROTO;\r\n  this['FUNCTION'] = this.FUNCTION; this['FUNCTION_PROTO'] = this.FUNCTION_PROTO;\r\n  this['ARRAY'] = this.ARRAY; this['ARRAY_PROTO'] = this.ARRAY_PROTO;\r\n  this['REGEXP'] = this.REGEXP; this['REGEXP_PROTO'] = this.REGEXP_PROTO;\r\n  // The following properties are obsolete.  Do not use.\r\n  this['UNDEFINED'] = undefined; this['NULL'] = null; this['NAN'] = NaN;\r\n  this['TRUE'] = true; this['FALSE'] = false; this['STRING_EMPTY'] = '';\r\n  this['NUMBER_ZERO'] = 0; this['NUMBER_ONE'] = 1;\r\n};\r\n\r\n/**\r\n * @const {!Object} Configuration used for all Acorn parsing.\r\n */\r\nstatic PARSE_OPTIONS = {\r\n  ecmaVersion: 5\r\n};\r\n\r\n/**\r\n * Property descriptor of readonly properties.\r\n */\r\nstatic READONLY_DESCRIPTOR = {\r\n  configurable: true,\r\n  enumerable: true,\r\n  writable: false\r\n};\r\n\r\n/**\r\n * Property descriptor of non-enumerable properties.\r\n */\r\nstatic NONENUMERABLE_DESCRIPTOR = {\r\n  configurable: true,\r\n  enumerable: false,\r\n  writable: true\r\n};\r\n\r\n/**\r\n * Property descriptor of readonly, non-enumerable properties.\r\n */\r\nstatic READONLY_NONENUMERABLE_DESCRIPTOR = {\r\n  configurable: true,\r\n  enumerable: false,\r\n  writable: false\r\n};\r\n\r\n/**\r\n * Property descriptor of variables.\r\n */\r\nstatic VARIABLE_DESCRIPTOR = {\r\n  configurable: false,\r\n  enumerable: true,\r\n  writable: true\r\n};\r\n\r\n/**\r\n * Unique symbol for indicating that a step has encountered an error, has\r\n * added it to the stack, and will be thrown within the user's program.\r\n * When STEP_ERROR is thrown in the JS-Interpreter, the error can be ignored.\r\n */\r\nstatic STEP_ERROR = {};\r\n\r\n/**\r\n * Unique symbol for indicating that a reference is a variable on the scope,\r\n * not an object property.\r\n */\r\nstatic SCOPE_REFERENCE = {};\r\n\r\n/**\r\n * For cycle detection in array to string and error conversion;\r\n * see spec bug github.com/tc39/ecma262/issues/289\r\n * Since this is for atomic actions only, it can be a class property.\r\n */\r\nstatic toStringCycles_ = [];\r\n\r\n/**\r\n * Add more code to the interpreter.\r\n * @param {string|!Object} code Raw JavaScript text or AST.\r\n */\r\npublic appendCode(code: string | ESTree.Node) {\r\n  var state = this.stateStack[0];\r\n  if (!state || state.node['type'] !== 'Program') {\r\n    throw Error('Expecting original AST to start with a Program node.');\r\n  }\r\n  if (typeof code === 'string') {\r\n    code = acorn.parse(code, Interpreter.PARSE_OPTIONS);\r\n  }\r\n  if (!code || code['type'] !== 'Program') {\r\n    throw Error('Expecting new AST to start with a Program node.');\r\n  }\r\n  this.populateScope_(code, state.scope);\r\n  // Append the new program to the old one.\r\n  for (var i = 0, node; (node = code['body'][i]); i++) {\r\n    state.node['body'].push(node);\r\n  }\r\n  state.done = false;\r\n};\r\n\r\n/**\r\n * Execute one step of the interpreter.\r\n * @return {boolean} True if a step was executed, false if no more instructions.\r\n */\r\npublic step(): boolean {\r\n  var stack = this.stateStack;\r\n  var state = stack[stack.length - 1];\r\n  if (!state) {\r\n    return false;\r\n  }\r\n  var node = state.node, type = node['type'];\r\n  if (type === 'Program' && state.done) {\r\n    return false;\r\n  } else if (this.paused_) {\r\n    return true;\r\n  }\r\n  try {\r\n    var nextState = this.stepFunctions_[type](stack, state, node);\r\n  } catch (e) {\r\n    // Eat any step errors.  They have been thrown on the stack.\r\n    if (e !== Interpreter.STEP_ERROR) {\r\n      // Uh oh.  This is a real error in the JS-Interpreter.  Rethrow.\r\n      throw e;\r\n    }\r\n  }\r\n  if (nextState) {\r\n    stack.push(nextState);\r\n  }\r\n  if (!node['end']) {\r\n    // This is polyfill code.  Keep executing until we arrive at user code.\r\n    return this.step();\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Execute the interpreter to program completion.  Vulnerable to infinite loops.\r\n * @return {boolean} True if a execution is asynchronously blocked,\r\n *     false if no more instructions.\r\n */\r\npublic run() {\r\n  while (!this.paused_ && this.step()) {}\r\n  return this.paused_;\r\n};\r\n\r\n/**\r\n * Initialize the global scope with buitin properties and functions.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initGlobalScope(scope: Interpreter.MyObject) {\r\n  // Initialize uneditable global properties.\r\n  this.setProperty(scope, 'NaN', NaN,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'Infinity', Infinity,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'undefined', undefined,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'window', scope,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'this', scope,\r\n                   Interpreter.READONLY_DESCRIPTOR);\r\n  this.setProperty(scope, 'self', scope); // Editable.\r\n\r\n  // Create the objects which will become Object.prototype and\r\n  // Function.prototype, which are needed to bootstrap everything else.\r\n  this.OBJECT_PROTO = new Interpreter.MyObject(null);\r\n  this.FUNCTION_PROTO = new Interpreter.MyObject(this.OBJECT_PROTO);\r\n  // Initialize global objects.\r\n  this.initFunction(scope);\r\n  this.initObject(scope);\r\n  // Unable to set scope's parent prior (OBJECT did not exist).\r\n  // Note that in a browser this would be 'Window', whereas in Node.js it would\r\n  // be 'Object'.  This interpreter is closer to Node in that it has no DOM.\r\n  scope.proto = this.OBJECT_PROTO;\r\n  this.setProperty(scope, 'constructor', this.OBJECT);\r\n  this.initArray(scope);\r\n  this.initString(scope);\r\n  this.initBoolean(scope);\r\n  this.initNumber(scope);\r\n  this.initDate(scope);\r\n  this.initRegExp(scope);\r\n  this.initError(scope);\r\n  this.initMath(scope);\r\n  this.initJSON(scope);\r\n\r\n  // Initialize global functions.\r\n  var thisInterpreter = this;\r\n  var func = this.createNativeFunction(\r\n      function(x) {throw EvalError(\"Can't happen\");}, false);\r\n  func.eval = true;\r\n  this.setProperty(scope, 'eval', func);\r\n\r\n  this.setProperty(scope, 'parseInt',\r\n      this.createNativeFunction(parseInt, false));\r\n  this.setProperty(scope, 'parseFloat',\r\n      this.createNativeFunction(parseFloat, false));\r\n\r\n  this.setProperty(scope, 'isNaN',\r\n      this.createNativeFunction(isNaN, false));\r\n\r\n  this.setProperty(scope, 'isFinite',\r\n      this.createNativeFunction(isFinite, false));\r\n\r\n  var strFunctions: any[] = [\r\n    [escape, 'escape'], [unescape, 'unescape'],\r\n    [decodeURI, 'decodeURI'], [decodeURIComponent, 'decodeURIComponent'],\r\n    [encodeURI, 'encodeURI'], [encodeURIComponent, 'encodeURIComponent']\r\n  ];\r\n  for (var i = 0; i < strFunctions.length; i++) {\r\n    var wrapper = (function(nativeFunc: (s: string) => string) {\r\n      return function(str) {\r\n        try {\r\n          return nativeFunc(str);\r\n        } catch (e) {\r\n          // decodeURI('%xy') will throw an error.  Catch and rethrow.\r\n          thisInterpreter.throwException(thisInterpreter.URI_ERROR, e.message);\r\n        }\r\n      };\r\n    })(strFunctions[i][0]);\r\n    this.setProperty(scope, strFunctions[i][1],\r\n        this.createNativeFunction(wrapper, false),\r\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n\r\n  // Run any user-provided initialization.\r\n  if (this.initFunc_) {\r\n    this.initFunc_(this, scope);\r\n  }\r\n};\r\n\r\n/**\r\n * Initialize the Function class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initFunction(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  var identifierRegexp = /^[A-Za-z_$][\\w$]*$/;\r\n  // Function constructor.\r\n  wrapper = function(var_args) {\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Function().\r\n      var newFunc = <Interpreter.MyObject>this;\r\n    } else {\r\n      // Called as Function().\r\n      var newFunc =\r\n          thisInterpreter.createObjectProto(thisInterpreter.FUNCTION_PROTO);\r\n    }\r\n    if (arguments.length) {\r\n      var code = String(arguments[arguments.length - 1]);\r\n    } else {\r\n      var code = '';\r\n    }\r\n    var args: string[] | string = [];\r\n    for (var i = 0; i < arguments.length - 1; i++) {\r\n      var name = String(arguments[i]);\r\n      if (!name.match(identifierRegexp)) {\r\n        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR,\r\n            'Invalid function argument: ' + name);\r\n      }\r\n      args.push(name);\r\n    }\r\n    args = args.join(', ');\r\n    // Interestingly, the scope for constructed functions is the global scope,\r\n    // even if they were constructed in some other scope.\r\n    newFunc.parentScope = thisInterpreter.global;\r\n    // Acorn needs to parse code in the context of a function or else 'return'\r\n    // statements will be syntax errors.\r\n    try {\r\n    var ast = acorn.parse('$ = function(' + args + ') {' + code + '};',\r\n        Interpreter.PARSE_OPTIONS);\r\n    } catch (e) {\r\n      // Acorn threw a SyntaxError.  Rethrow as a trappable error.\r\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR,\r\n          'Invalid code: ' + e.message);\r\n    }\r\n    if (ast['body'].length !== 1) {\r\n      // Function('a', 'return a + 6;}; {alert(1);');\r\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR,\r\n          'Invalid code in function body.');\r\n    }\r\n    newFunc.node = ast['body'][0]['expression']['right'];\r\n    thisInterpreter.setProperty(newFunc, 'length', newFunc.node['length'],\r\n        Interpreter.READONLY_DESCRIPTOR);\r\n    return newFunc;\r\n  };\r\n  wrapper.id = this.functionCounter_++;\r\n  this.FUNCTION = this.createObjectProto(this.FUNCTION_PROTO);\r\n\r\n  this.setProperty(scope, 'Function', this.FUNCTION);\r\n  // Manually setup type and prototype because createObj doesn't recognize\r\n  // this object as a function (this.FUNCTION did not exist).\r\n  this.setProperty(this.FUNCTION, 'prototype', this.FUNCTION_PROTO);\r\n  this.FUNCTION.nativeFunc = wrapper;\r\n\r\n  // Configure Function.prototype.\r\n  this.setProperty(this.FUNCTION_PROTO, 'constructor', this.FUNCTION,\r\n                   Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  this.FUNCTION_PROTO.nativeFunc = function() {};\r\n  this.FUNCTION_PROTO.nativeFunc.id = this.functionCounter_++;\r\n  this.setProperty(this.FUNCTION_PROTO, 'length', 0,\r\n      Interpreter.READONLY_DESCRIPTOR);\r\n\r\n  var boxThis = function(value) {\r\n    // In non-strict mode 'this' must be an object.\r\n    if ((!value || !value.isObject) && !thisInterpreter.getScope().strict) {\r\n      if (value === undefined || value === null) {\r\n        // 'Undefined' and 'null' are changed to global object.\r\n        value = thisInterpreter.global;\r\n      } else {\r\n        // Primitives must be boxed in non-strict mode.\r\n        var box = thisInterpreter.createObjectProto(\r\n            thisInterpreter.getPrototype(value));\r\n        box.data = value;\r\n        value = box;\r\n      }\r\n    }\r\n    return value;\r\n  };\r\n\r\n  wrapper = function(thisArg, args) {\r\n    var state =\r\n        thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\r\n    // Rewrite the current 'CallExpression' to apply a different function.\r\n    state.func_ = this;\r\n    // Assign the 'this' object.\r\n    state.funcThis_ = boxThis(thisArg);\r\n    // Bind any provided arguments.\r\n    state.arguments_ = [];\r\n    if (args !== null && args !== undefined) {\r\n      if (args.isObject) {\r\n        state.arguments_ = thisInterpreter.pseudoToNative(args);\r\n      } else {\r\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n            'CreateListFromArrayLike called on non-object');\r\n      }\r\n    }\r\n    state.doneExec_ = false;\r\n  };\r\n  this.setNativeFunctionPrototype(this.FUNCTION, 'apply', wrapper);\r\n\r\n  wrapper = function(thisArg, var_args) {\r\n    var state =\r\n        thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\r\n    // Rewrite the current 'CallExpression' to call a different function.\r\n    state.func_ = this;\r\n    // Assign the 'this' object.\r\n    state.funcThis_ = boxThis(thisArg);\r\n    // Bind any provided arguments.\r\n    state.arguments_ = [];\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      state.arguments_.push(arguments[i]);\r\n    }\r\n    state.doneExec_ = false;\r\n  };\r\n  this.setNativeFunctionPrototype(this.FUNCTION, 'call', wrapper);\r\n\r\n  this.polyfills_.push(\r\n// Polyfill copied from:\r\n// developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\r\n\"Object.defineProperty(Function.prototype, 'bind',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(oThis) {\",\r\n    \"if (typeof this !== 'function') {\",\r\n      \"throw TypeError('What is trying to be bound is not callable');\",\r\n    \"}\",\r\n    \"var aArgs   = Array.prototype.slice.call(arguments, 1),\",\r\n        \"fToBind = this,\",\r\n        \"fNOP    = function() {},\",\r\n        \"fBound  = function() {\",\r\n          \"return fToBind.apply(this instanceof fNOP\",\r\n                 \"? this\",\r\n                 \": oThis,\",\r\n                 \"aArgs.concat(Array.prototype.slice.call(arguments)));\",\r\n        \"};\",\r\n    \"if (this.prototype) {\",\r\n      \"fNOP.prototype = this.prototype;\",\r\n    \"}\",\r\n    \"fBound.prototype = new fNOP();\",\r\n    \"return fBound;\",\r\n  \"}\",\r\n\"});\",\r\n\"\");\r\n\r\n  // Function has no parent to inherit from, so it needs its own mandatory\r\n  // toString and valueOf functions.\r\n  wrapper = function() {\r\n    return this.toString();\r\n  };\r\n  this.setNativeFunctionPrototype(this.FUNCTION, 'toString', wrapper);\r\n  this.setProperty(this.FUNCTION, 'toString',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  wrapper = function() {\r\n    return this.valueOf();\r\n  };\r\n  this.setNativeFunctionPrototype(this.FUNCTION, 'valueOf', wrapper);\r\n  this.setProperty(this.FUNCTION, 'valueOf',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n};\r\n\r\n/**\r\n * Initialize the Object class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initObject(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // Object constructor.\r\n  wrapper = function(value) {\r\n    if (value === undefined || value === null) {\r\n      // Create a new object.\r\n      if (thisInterpreter.calledWithNew()) {\r\n        // Called as new Object().\r\n        return this;\r\n      } else {\r\n        // Called as Object().\r\n        return thisInterpreter.createObjectProto(thisInterpreter.OBJECT_PROTO);\r\n      }\r\n    }\r\n    if (!value.isObject) {\r\n      // Wrap the value as an object.\r\n      var box = thisInterpreter.createObjectProto(\r\n          thisInterpreter.getPrototype(value));\r\n      box.data = value;\r\n      return box;\r\n    }\r\n    // Return the provided object.\r\n    return value;\r\n  };\r\n  this.OBJECT = this.createNativeFunction(wrapper, true);\r\n  // Throw away the created prototype and use the root prototype.\r\n  this.setProperty(this.OBJECT, 'prototype', this.OBJECT_PROTO);\r\n  this.setProperty(this.OBJECT_PROTO, 'constructor', this.OBJECT);\r\n  this.setProperty(scope, 'Object', this.OBJECT);\r\n\r\n  /**\r\n   * Checks if the provided value is null or undefined.\r\n   * If so, then throw an error in the call stack.\r\n   * @param {Interpreter.MyValue} value Value to check.\r\n   */\r\n  var throwIfNullUndefined = function(value) {\r\n    if (value === undefined || value === null) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          \"Cannot convert '\" + value + \"' to object\");\r\n    }\r\n  };\r\n\r\n  // Static methods on Object.\r\n  wrapper = function(obj) {\r\n    throwIfNullUndefined(obj);\r\n    var props = obj.isObject ? obj.properties : obj;\r\n    return thisInterpreter.nativeToPseudo(Object.getOwnPropertyNames(props));\r\n  };\r\n  this.setProperty(this.OBJECT, 'getOwnPropertyNames',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(obj) {\r\n    throwIfNullUndefined(obj);\r\n    if (!obj.isObject) {\r\n      return thisInterpreter.nativeToPseudo(Object.keys(obj));\r\n    }\r\n    return thisInterpreter.nativeToPseudo(Object.keys(obj.properties));\r\n  };\r\n  this.setProperty(this.OBJECT, 'keys',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(proto) {\r\n    // Support for the second argument is the responsibility of a polyfill.\r\n    if (proto === null) {\r\n      return thisInterpreter.createObjectProto(null);\r\n    }\r\n    if (proto === undefined || !proto.isObject) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          'Object prototype may only be an Object or null');\r\n    }\r\n    return thisInterpreter.createObjectProto(proto);\r\n  };\r\n  this.setProperty(this.OBJECT, 'create',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Add a polyfill to handle create's second argument.\r\n  this.polyfills_.push(\r\n\"(function() {\",\r\n  \"var create_ = Object.create;\",\r\n  \"Object.create = function(proto, props) {\",\r\n    \"var obj = create_(proto);\",\r\n    \"props && Object.defineProperties(obj, props);\",\r\n    \"return obj;\",\r\n  \"};\",\r\n\"})();\",\r\n\"\");\r\n\r\n  wrapper = function(obj, prop, descriptor) {\r\n    prop = String(prop);\r\n    if (!obj || !obj.isObject) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          'Object.defineProperty called on non-object');\r\n    }\r\n    if (!descriptor || !descriptor.isObject) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          'Property description must be an object');\r\n    }\r\n    if (!obj.properties[prop] && obj.preventExtensions) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          \"Can't define property '\" + prop + \"', object is not extensible\");\r\n    }\r\n    // The polyfill guarantees no inheritance and no getter functions.\r\n    // Therefore the descriptor properties map is the native object needed.\r\n    thisInterpreter.setProperty(obj, prop, ReferenceError,\r\n                                descriptor.properties);\r\n    return obj;\r\n  };\r\n  this.setProperty(this.OBJECT, 'defineProperty',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  this.polyfills_.push(\r\n// Flatten the descriptor to remove any inheritance or getter functions.\r\n\"(function() {\",\r\n  \"var defineProperty_ = Object.defineProperty;\",\r\n  \"Object.defineProperty = function(obj, prop, d1) {\",\r\n    \"var d2 = {};\",\r\n    \"if ('configurable' in d1) d2.configurable = d1.configurable;\",\r\n    \"if ('enumerable' in d1) d2.enumerable = d1.enumerable;\",\r\n    \"if ('writable' in d1) d2.writable = d1.writable;\",\r\n    \"if ('value' in d1) d2.value = d1.value;\",\r\n    \"if ('get' in d1) d2.get = d1.get;\",\r\n    \"if ('set' in d1) d2.set = d1.set;\",\r\n    \"return defineProperty_(obj, prop, d2);\",\r\n  \"};\",\r\n\"})();\",\r\n\r\n\"Object.defineProperty(Object, 'defineProperties',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(obj, props) {\",\r\n    \"var keys = Object.keys(props);\",\r\n    \"for (var i = 0; i < keys.length; i++) {\",\r\n      \"Object.defineProperty(obj, keys[i], props[keys[i]]);\",\r\n    \"}\",\r\n    \"return obj;\",\r\n  \"}\",\r\n\"});\",\r\n\"\");\r\n\r\n  wrapper = function(obj, prop) {\r\n    if (!obj || !obj.isObject) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\r\n          'Object.getOwnPropertyDescriptor called on non-object');\r\n    }\r\n    prop = String(prop);\r\n    if (!(prop in obj.properties)) {\r\n      return undefined;\r\n    }\r\n    var descriptor = Object.getOwnPropertyDescriptor(obj.properties, prop);\r\n    var getter = obj.getter[prop];\r\n    var setter = obj.setter[prop];\r\n\r\n    if (getter || setter) {\r\n      descriptor.get = getter;\r\n      descriptor.set = setter;\r\n      delete descriptor.value;\r\n      delete descriptor.writable;\r\n    }\r\n    var pseudoDescriptor = <Interpreter.MyObject>thisInterpreter.nativeToPseudo(descriptor);\r\n    if ('value' in descriptor) {\r\n      thisInterpreter.setProperty(pseudoDescriptor, 'value', descriptor.value);\r\n    }\r\n    return pseudoDescriptor;\r\n  };\r\n  this.setProperty(this.OBJECT, 'getOwnPropertyDescriptor',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(obj) {\r\n    throwIfNullUndefined(obj);\r\n    return thisInterpreter.getPrototype(obj);\r\n  };\r\n  this.setProperty(this.OBJECT, 'getPrototypeOf',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(obj) {\r\n    return Boolean(obj) && !obj.preventExtensions;\r\n  };\r\n  this.setProperty(this.OBJECT, 'isExtensible',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(obj) {\r\n    if (obj && obj.isObject) {\r\n      obj.preventExtensions = true;\r\n    }\r\n    return obj;\r\n  };\r\n  this.setProperty(this.OBJECT, 'preventExtensions',\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Instance methods on Object.\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'toString',\r\n      Interpreter.MyObject.prototype.toString);\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'toLocaleString',\r\n      Interpreter.MyObject.prototype.toString);\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'valueOf',\r\n      Interpreter.MyObject.prototype.valueOf);\r\n\r\n  wrapper = function(prop) {\r\n    throwIfNullUndefined(this);\r\n    if (!this.isObject) {\r\n      return this.hasOwnProperty(prop);\r\n    }\r\n    return String(prop) in this.properties;\r\n  };\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'hasOwnProperty', wrapper);\r\n\r\n  wrapper = function(prop) {\r\n    throwIfNullUndefined(this);\r\n    return Object.prototype.propertyIsEnumerable.call(this.properties, prop);\r\n  };\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'propertyIsEnumerable', wrapper);\r\n\r\n  wrapper = function(obj) {\r\n    while (true) {\r\n      // Note, circular loops shouldn't be possible.\r\n      obj = thisInterpreter.getPrototype(obj);\r\n      if (!obj) {\r\n        // No parent; reached the top.\r\n        return false;\r\n      }\r\n      if (obj === this) {\r\n        return true;\r\n      }\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.OBJECT, 'isPrototypeOf',  wrapper);\r\n};\r\n\r\n/**\r\n * Initialize the Array class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initArray(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var getInt = function(obj, def) {\r\n    // Return an integer, or the default.\r\n    var n = obj ? Math.floor(obj) : def;\r\n    if (isNaN(n)) {\r\n      n = def;\r\n    }\r\n    return n;\r\n  };\r\n  var wrapper;\r\n  // Array constructor.\r\n  wrapper = function(var_args) {\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Array().\r\n      var newArray = <Interpreter.MyObject>this;\r\n    } else {\r\n      // Called as Array().\r\n      var newArray =\r\n          thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\r\n    }\r\n    var first = arguments[0];\r\n    if (arguments.length === 1 && typeof first === 'number') {\r\n      if (isNaN(Interpreter.legalArrayLength(first))) {\r\n        thisInterpreter.throwException(thisInterpreter.RANGE_ERROR,\r\n                                       'Invalid array length');\r\n      }\r\n      newArray.properties.length = first;\r\n    } else {\r\n      for (var i = 0; i < arguments.length; i++) {\r\n        newArray.properties[i] = arguments[i];\r\n      }\r\n      newArray.properties.length = i;\r\n    }\r\n    return newArray;\r\n  };\r\n  this.ARRAY = this.createNativeFunction(wrapper, true);\r\n  this.ARRAY_PROTO = this.ARRAY.properties['prototype'];\r\n  this.setProperty(scope, 'Array', this.ARRAY);\r\n\r\n  // Static methods on Array.\r\n  wrapper = function(obj) {\r\n    return obj && obj.class === 'Array';\r\n  };\r\n  this.setProperty(this.ARRAY, 'isArray',\r\n                   this.createNativeFunction(wrapper, false),\r\n                   Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Instance methods on Array.\r\n  wrapper = function() {\r\n    return Array.prototype.pop.call(this.properties);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'pop', wrapper);\r\n\r\n  wrapper = function(var_args) {\r\n    return Array.prototype.push.apply(this.properties, arguments);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'push', wrapper);\r\n\r\n  wrapper = function() {\r\n    return Array.prototype.shift.call(this.properties);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'shift', wrapper);\r\n\r\n  wrapper = function(var_args) {\r\n    return Array.prototype.unshift.apply(this.properties, arguments);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'unshift', wrapper);\r\n\r\n  wrapper = function() {\r\n    Array.prototype.reverse.call(this.properties);\r\n    return this;\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'reverse', wrapper);\r\n\r\n  wrapper = function(index, howmany /*, var_args*/) {\r\n    var list = Array.prototype.splice.apply(this.properties, arguments);\r\n    return thisInterpreter.nativeToPseudo(list);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'splice', wrapper);\r\n\r\n  wrapper = function(opt_begin, opt_end) {\r\n    var list = Array.prototype.slice.call(this.properties, opt_begin, opt_end);\r\n    return thisInterpreter.nativeToPseudo(list);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'slice', wrapper);\r\n\r\n  wrapper = function(opt_separator) {\r\n    return Array.prototype.join.call(this.properties, opt_separator);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'join', wrapper);\r\n\r\n  wrapper = function(var_args) {\r\n    var list = [];\r\n    var length = 0;\r\n    // Start by copying the current array.\r\n    var iLength = thisInterpreter.getProperty(this, 'length');\r\n    for (var i = 0; i < iLength; i++) {\r\n      if (thisInterpreter.hasProperty(this, i)) {\r\n        var element = thisInterpreter.getProperty(this, i);\r\n        list[length] = element;\r\n      }\r\n      length++;\r\n    }\r\n    // Loop through all arguments and copy them in.\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      var value = arguments[i];\r\n      if (thisInterpreter.isa(value, thisInterpreter.ARRAY)) {\r\n        var jLength = thisInterpreter.getProperty(value, 'length');\r\n        for (var j = 0; j < jLength; j++) {\r\n          if (thisInterpreter.hasProperty(value, j)) {\r\n            list[length] = thisInterpreter.getProperty(value, j);\r\n          }\r\n          length++;\r\n        }\r\n      } else {\r\n        list[length] = value;\r\n      }\r\n    }\r\n    return thisInterpreter.nativeToPseudo(list);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'concat', wrapper);\r\n\r\n  wrapper = function(searchElement, opt_fromIndex) {\r\n    return Array.prototype.indexOf.apply(this.properties, arguments);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'indexOf', wrapper);\r\n\r\n  wrapper = function(searchElement, opt_fromIndex) {\r\n    return Array.prototype.lastIndexOf.apply(this.properties, arguments);\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'lastIndexOf', wrapper);\r\n\r\n  wrapper = function() {\r\n    Array.prototype.sort.call(this.properties);\r\n    return this;\r\n  };\r\n  this.setNativeFunctionPrototype(this.ARRAY, 'sort', wrapper);\r\n\r\n  this.polyfills_.push(\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/every\r\n\"Object.defineProperty(Array.prototype, 'every',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callbackfn, thisArg) {\",\r\n    \"if (!this || typeof callbackfn !== 'function') throw TypeError();\",\r\n    \"var T, k;\",\r\n    \"var O = Object(this);\",\r\n    \"var len = O.length >>> 0;\",\r\n    \"if (arguments.length > 1) T = thisArg;\",\r\n    \"k = 0;\",\r\n    \"while (k < len) {\",\r\n      \"if (k in O && !callbackfn.call(T, O[k], k, O)) return false;\",\r\n      \"k++;\",\r\n    \"}\",\r\n    \"return true;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\r\n\"Object.defineProperty(Array.prototype, 'filter',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(fun/*, thisArg*/) {\",\r\n    \"if (this === void 0 || this === null || typeof fun !== 'function') throw TypeError();\",\r\n    \"var t = Object(this);\",\r\n    \"var len = t.length >>> 0;\",\r\n    \"var res = [];\",\r\n    \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\",\r\n    \"for (var i = 0; i < len; i++) {\",\r\n      \"if (i in t) {\",\r\n        \"var val = t[i];\",\r\n        \"if (fun.call(thisArg, val, i, t)) res.push(val);\",\r\n      \"}\",\r\n    \"}\",\r\n    \"return res;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n\"Object.defineProperty(Array.prototype, 'forEach',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callback, thisArg) {\",\r\n    \"if (!this || typeof callback !== 'function') throw TypeError();\",\r\n    \"var T, k;\",\r\n    \"var O = Object(this);\",\r\n    \"var len = O.length >>> 0;\",\r\n    \"if (arguments.length > 1) T = thisArg;\",\r\n    \"k = 0;\",\r\n    \"while (k < len) {\",\r\n      \"if (k in O) callback.call(T, O[k], k, O);\",\r\n      \"k++;\",\r\n    \"}\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map\r\n\"Object.defineProperty(Array.prototype, 'map',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callback, thisArg) {\",\r\n    \"if (!this || typeof callback !== 'function') new TypeError;\",\r\n    \"var T, A, k;\",\r\n    \"var O = Object(this);\",\r\n    \"var len = O.length >>> 0;\",\r\n    \"if (arguments.length > 1) T = thisArg;\",\r\n    \"A = new Array(len);\",\r\n    \"k = 0;\",\r\n    \"while (k < len) {\",\r\n      \"if (k in O) A[k] = callback.call(T, O[k], k, O);\",\r\n      \"k++;\",\r\n    \"}\",\r\n    \"return A;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\r\n\"Object.defineProperty(Array.prototype, 'reduce',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callback /*, initialValue*/) {\",\r\n    \"if (!this || typeof callback !== 'function') throw TypeError();\",\r\n    \"var t = Object(this), len = t.length >>> 0, k = 0, value;\",\r\n    \"if (arguments.length === 2) {\",\r\n      \"value = arguments[1];\",\r\n    \"} else {\",\r\n      \"while (k < len && !(k in t)) k++;\",\r\n      \"if (k >= len) {\",\r\n        \"throw TypeError('Reduce of empty array with no initial value');\",\r\n      \"}\",\r\n      \"value = t[k++];\",\r\n    \"}\",\r\n    \"for (; k < len; k++) {\",\r\n      \"if (k in t) value = callback(value, t[k], k, t);\",\r\n    \"}\",\r\n    \"return value;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\r\n\"Object.defineProperty(Array.prototype, 'reduceRight',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(callback /*, initialValue*/) {\",\r\n    \"if (null === this || 'undefined' === typeof this || 'function' !== typeof callback) throw TypeError();\",\r\n    \"var t = Object(this), len = t.length >>> 0, k = len - 1, value;\",\r\n    \"if (arguments.length >= 2) {\",\r\n      \"value = arguments[1];\",\r\n    \"} else {\",\r\n      \"while (k >= 0 && !(k in t)) k--;\",\r\n      \"if (k < 0) {\",\r\n        \"throw TypeError('Reduce of empty array with no initial value');\",\r\n      \"}\",\r\n      \"value = t[k--];\",\r\n    \"}\",\r\n    \"for (; k >= 0; k--) {\",\r\n      \"if (k in t) value = callback(value, t[k], k, t);\",\r\n    \"}\",\r\n    \"return value;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n// Polyfill copied from:\r\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/some\r\n\"Object.defineProperty(Array.prototype, 'some',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function(fun/*, thisArg*/) {\",\r\n    \"if (!this || typeof fun !== 'function') throw TypeError();\",\r\n    \"var t = Object(this);\",\r\n    \"var len = t.length >>> 0;\",\r\n    \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\",\r\n    \"for (var i = 0; i < len; i++) {\",\r\n      \"if (i in t && fun.call(thisArg, t[i], i, t)) {\",\r\n        \"return true;\",\r\n      \"}\",\r\n    \"}\",\r\n    \"return false;\",\r\n  \"}\",\r\n\"});\",\r\n\r\n\r\n\"(function() {\",\r\n  \"var sort_ = Array.prototype.sort;\",\r\n  \"Array.prototype.sort = function(opt_comp) {\",\r\n    // Fast native sort.\r\n    \"if (typeof opt_comp !== 'function') {\",\r\n      \"return sort_.call(this);\",\r\n    \"}\",\r\n    // Slow bubble sort.\r\n    \"for (var i = 0; i < this.length; i++) {\",\r\n      \"var changes = 0;\",\r\n      \"for (var j = 0; j < this.length - i - 1; j++) {\",\r\n        \"if (opt_comp(this[j], this[j + 1]) > 0) {\",\r\n          \"var swap = this[j];\",\r\n          \"this[j] = this[j + 1];\",\r\n          \"this[j + 1] = swap;\",\r\n          \"changes++;\",\r\n        \"}\",\r\n      \"}\",\r\n      \"if (!changes) break;\",\r\n    \"}\",\r\n    \"return this;\",\r\n  \"};\",\r\n\"})();\",\r\n\r\n\"Object.defineProperty(Array.prototype, 'toLocaleString',\",\r\n    \"{configurable: true, writable: true, value:\",\r\n  \"function() {\",\r\n    \"var out = [];\",\r\n    \"for (var i = 0; i < this.length; i++) {\",\r\n      \"out[i] = (this[i] === null || this[i] === undefined) ? '' : this[i].toLocaleString();\",\r\n    \"}\",\r\n    \"return out.join(',');\",\r\n  \"}\",\r\n\"});\",\r\n\"\");\r\n};\r\n\r\n/**\r\n * Initialize the String class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initString(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // String constructor.\r\n  wrapper = function(value) {\r\n    value = String(value);\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new String().\r\n      this.data = value;\r\n      return this;\r\n    } else {\r\n      // Called as String().\r\n      return value;\r\n    }\r\n  };\r\n  this.STRING = this.createNativeFunction(wrapper, true);\r\n  this.setProperty(scope, 'String', this.STRING);\r\n\r\n  // Static methods on String.\r\n  this.setProperty(this.STRING, 'fromCharCode',\r\n      this.createNativeFunction(String.fromCharCode, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Instance methods on String.\r\n  // Methods with exclusively primitive arguments.\r\n  var functions = ['trim', 'toLowerCase', 'toUpperCase',\r\n      'toLocaleLowerCase', 'toLocaleUpperCase', 'charAt', 'charCodeAt',\r\n      'substring', 'slice', 'substr', 'indexOf', 'lastIndexOf', 'concat'];\r\n  for (var i = 0; i < functions.length; i++) {\r\n    this.setNativeFunctionPrototype(this.STRING, functions[i],\r\n                                    String.prototype[functions[i]]);\r\n  }\r\n\r\n  wrapper = function(compareString, locales, options) {\r\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\r\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\r\n    return String(this).localeCompare(compareString, locales, options);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'localeCompare', wrapper);\r\n\r\n  wrapper = function(separator, limit) {\r\n    if (thisInterpreter.isa(separator, thisInterpreter.REGEXP)) {\r\n      separator = separator.data;\r\n    }\r\n    var jsList = String(this).split(separator, limit);\r\n    return thisInterpreter.nativeToPseudo(jsList);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'split', wrapper);\r\n\r\n  wrapper = function(regexp) {\r\n    regexp = regexp ? regexp.data : undefined;\r\n    var match = String(this).match(regexp);\r\n    if (!match) {\r\n      return null;\r\n    }\r\n    return thisInterpreter.nativeToPseudo(match);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'match', wrapper);\r\n\r\n  wrapper = function(regexp) {\r\n    regexp = regexp ? regexp.data : undefined;\r\n    return String(this).search(regexp);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'search', wrapper);\r\n\r\n  wrapper = function(substr, newSubstr) {\r\n    // Support for function replacements is the responsibility of a polyfill.\r\n    return String(this).replace(substr.data || substr, newSubstr);\r\n  };\r\n  this.setNativeFunctionPrototype(this.STRING, 'replace', wrapper);\r\n  // Add a polyfill to handle replace's second argument being a function.\r\n  this.polyfills_.push(\r\n\"(function() {\",\r\n  \"var replace_ = String.prototype.replace;\",\r\n  \"String.prototype.replace = function(substr, newSubstr) {\",\r\n    \"if (typeof newSubstr !== 'function') {\",\r\n      // string.replace(string|regexp, string)\r\n      \"return replace_.call(this, substr, newSubstr);\",\r\n    \"}\",\r\n    \"var str = this;\",\r\n    \"if (substr instanceof RegExp) {\",  // string.replace(regexp, function)\r\n      \"var subs = [];\",\r\n      \"var m = substr.exec(str);\",\r\n      \"while (m) {\",\r\n        \"m.push(m.index, str);\",\r\n        \"var inject = newSubstr.apply(null, m);\",\r\n        \"subs.push([m.index, m[0].length, inject]);\",\r\n        \"m = substr.global ? substr.exec(str) : null;\",\r\n      \"}\",\r\n      \"for (var i = subs.length - 1; i >= 0; i--) {\",\r\n        \"str = str.substring(0, subs[i][0]) + subs[i][2] + \" +\r\n            \"str.substring(subs[i][0] + subs[i][1]);\",\r\n      \"}\",\r\n    \"} else {\",                         // string.replace(string, function)\r\n      \"var i = str.indexOf(substr);\",\r\n      \"if (i !== -1) {\",\r\n        \"var inject = newSubstr(str.substr(i, substr.length), i, str);\",\r\n        \"str = str.substring(0, i) + inject + \" +\r\n            \"str.substring(i + substr.length);\",\r\n      \"}\",\r\n    \"}\",\r\n    \"return str;\",\r\n  \"};\",\r\n\"})();\",\r\n\"\");\r\n};\r\n\r\n/**\r\n * Initialize the Boolean class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initBoolean(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // Boolean constructor.\r\n  wrapper = function(value) {\r\n    value = Boolean(value);\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Boolean().\r\n      this.data = value;\r\n      return this;\r\n    } else {\r\n      // Called as Boolean().\r\n      return value;\r\n    }\r\n  };\r\n  this.BOOLEAN = this.createNativeFunction(wrapper, true);\r\n  this.setProperty(scope, 'Boolean', this.BOOLEAN);\r\n};\r\n\r\n/**\r\n * Initialize the Number class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initNumber(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // Number constructor.\r\n  wrapper = function(value) {\r\n    value = Number(value);\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Number().\r\n      this.data = value;\r\n      return this;\r\n    } else {\r\n      // Called as Number().\r\n      return value;\r\n    }\r\n  };\r\n  this.NUMBER = this.createNativeFunction(wrapper, true);\r\n  this.setProperty(scope, 'Number', this.NUMBER);\r\n\r\n  var numConsts = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY',\r\n                   'POSITIVE_INFINITY'];\r\n  for (var i = 0; i < numConsts.length; i++) {\r\n    this.setProperty(this.NUMBER, numConsts[i], Number[numConsts[i]],\r\n        Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n\r\n  // Instance methods on Number.\r\n  wrapper = function(fractionDigits) {\r\n    try {\r\n      return Number(this).toExponential(fractionDigits);\r\n    } catch (e) {\r\n      // Throws if fractionDigits isn't within 0-20.\r\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toExponential', wrapper);\r\n\r\n  wrapper = function(digits) {\r\n    try {\r\n      return Number(this).toFixed(digits);\r\n    } catch (e) {\r\n      // Throws if digits isn't within 0-20.\r\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toFixed', wrapper);\r\n\r\n  wrapper = function(precision) {\r\n    try {\r\n      return Number(this).toPrecision(precision);\r\n    } catch (e) {\r\n      // Throws if precision isn't within range (depends on implementation).\r\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toPrecision', wrapper);\r\n\r\n  wrapper = function(radix) {\r\n    try {\r\n      return Number(this).toString(radix);\r\n    } catch (e) {\r\n      // Throws if radix isn't within 2-36.\r\n      thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\r\n    }\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toString', wrapper);\r\n\r\n  wrapper = function(locales, options) {\r\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\r\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\r\n    return Number(this).toLocaleString(locales, options);\r\n  };\r\n  this.setNativeFunctionPrototype(this.NUMBER, 'toLocaleString', wrapper);\r\n};\r\n\r\n/**\r\n * Initialize the Date class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initDate(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // Date constructor.\r\n  wrapper = function(value, var_args) {\r\n    if (!thisInterpreter.calledWithNew()) {\r\n      // Called as Date().\r\n      // Calling Date() as a function returns a string, no arguments are heeded.\r\n      return Date();\r\n    }\r\n    // Called as new Date().\r\n    var args = [null].concat([].slice.call(arguments));\r\n    this.data = new (Function.prototype.bind.apply(Date, args));\r\n    return this;\r\n  };\r\n  this.DATE = this.createNativeFunction(wrapper, true);\r\n  this.setProperty(scope, 'Date', this.DATE);\r\n\r\n  // Static methods on Date.\r\n  this.setProperty(this.DATE, 'now', this.createNativeFunction(Date.now, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  this.setProperty(this.DATE, 'parse',\r\n      this.createNativeFunction(Date.parse, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  this.setProperty(this.DATE, 'UTC', this.createNativeFunction(Date.UTC, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  // Instance methods on Date.\r\n  var functions = ['getDate', 'getDay', 'getFullYear', 'getHours',\r\n      'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTime',\r\n      'getTimezoneOffset', 'getUTCDate', 'getUTCDay', 'getUTCFullYear',\r\n      'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth',\r\n      'getUTCSeconds', 'getYear',\r\n      'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\r\n      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate',\r\n      'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes',\r\n      'setUTCMonth', 'setUTCSeconds', 'setYear',\r\n      'toDateString', 'toISOString', 'toJSON', 'toGMTString',\r\n      'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString',\r\n      'toTimeString', 'toUTCString'];\r\n  for (var i = 0; i < functions.length; i++) {\r\n    wrapper = (function(nativeFunc) {\r\n      return function(var_args) {\r\n        var args = [];\r\n        for (var i = 0; i < arguments.length; i++) {\r\n          args[i] = thisInterpreter.pseudoToNative(arguments[i]);\r\n        }\r\n        return this.data[nativeFunc].apply(this.data, args);\r\n      };\r\n    })(functions[i]);\r\n    this.setNativeFunctionPrototype(this.DATE, functions[i], wrapper);\r\n  }\r\n};\r\n\r\n/**\r\n * Initialize Regular Expression object.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initRegExp(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var wrapper;\r\n  // RegExp constructor.\r\n  wrapper = function(pattern, flags) {\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new RegExp().\r\n      var rgx = <Interpreter.MyObject>this;\r\n    } else {\r\n      // Called as RegExp().\r\n      var rgx = thisInterpreter.createObjectProto(thisInterpreter.REGEXP_PROTO);\r\n    }\r\n    pattern = pattern ? pattern.toString() : '';\r\n    flags = flags ? flags.toString() : '';\r\n    thisInterpreter.populateRegExp(rgx, new RegExp(pattern, flags));\r\n    return rgx;\r\n  };\r\n  this.REGEXP = this.createNativeFunction(wrapper, true);\r\n  this.REGEXP_PROTO = this.REGEXP.properties['prototype'];\r\n  this.setProperty(scope, 'RegExp', this.REGEXP);\r\n\r\n  this.setProperty(this.REGEXP.properties['prototype'], 'global', undefined,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(this.REGEXP.properties['prototype'], 'ignoreCase', undefined,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(this.REGEXP.properties['prototype'], 'multiline', undefined,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(this.REGEXP.properties['prototype'], 'source', '(?:)',\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n\r\n  wrapper = function(str) {\r\n    return this.data.test(str);\r\n  };\r\n  this.setNativeFunctionPrototype(this.REGEXP, 'test', wrapper);\r\n\r\n  wrapper = function(str) {\r\n    str = str.toString();\r\n    // Get lastIndex from wrapped regex, since this is settable.\r\n    this.data.lastIndex =\r\n        Number(thisInterpreter.getProperty(this, 'lastIndex'));\r\n    var match = this.data.exec(str);\r\n    thisInterpreter.setProperty(this, 'lastIndex', this.data.lastIndex);\r\n\r\n    if (match) {\r\n      var result =\r\n          thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\r\n      for (var i = 0; i < match.length; i++) {\r\n        thisInterpreter.setProperty(result, i, match[i]);\r\n      }\r\n      // match has additional properties.\r\n      thisInterpreter.setProperty(result, 'index', match.index);\r\n      thisInterpreter.setProperty(result, 'input', match.input);\r\n      return result;\r\n    }\r\n    return null;\r\n  };\r\n  this.setNativeFunctionPrototype(this.REGEXP, 'exec', wrapper);\r\n};\r\n\r\n/**\r\n * Initialize the Error class.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initError(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  // Error constructor.\r\n  this.ERROR = this.createNativeFunction(function(opt_message) {\r\n    if (thisInterpreter.calledWithNew()) {\r\n      // Called as new Error().\r\n      var newError = <Interpreter.MyObject>this;\r\n    } else {\r\n      // Called as Error().\r\n      var newError = thisInterpreter.createObject(thisInterpreter.ERROR);\r\n    }\r\n    if (opt_message) {\r\n      thisInterpreter.setProperty(newError, 'message', String(opt_message),\r\n          Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n    }\r\n    return newError;\r\n  }, true);\r\n  this.setProperty(scope, 'Error', this.ERROR);\r\n  this.setProperty(this.ERROR.properties['prototype'], 'message', '',\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(this.ERROR.properties['prototype'], 'name', 'Error',\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n\r\n  var createErrorSubclass = function(name) {\r\n    var constructor = thisInterpreter.createNativeFunction(\r\n        function(opt_message) {\r\n          if (thisInterpreter.calledWithNew()) {\r\n            // Called as new XyzError().\r\n            var newError = <Interpreter.MyObject>this;\r\n          } else {\r\n            // Called as XyzError().\r\n            var newError = thisInterpreter.createObject(constructor);\r\n          }\r\n          if (opt_message) {\r\n            thisInterpreter.setProperty(newError, 'message',\r\n                String(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n          }\r\n          return newError;\r\n        }, true);\r\n    thisInterpreter.setProperty(constructor, 'prototype',\r\n        thisInterpreter.createObject(thisInterpreter.ERROR));\r\n    thisInterpreter.setProperty(constructor.properties['prototype'], 'name',\r\n        name, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n    thisInterpreter.setProperty(scope, name, constructor);\r\n\r\n    return constructor;\r\n  };\r\n\r\n  this.EVAL_ERROR = createErrorSubclass('EvalError');\r\n  this.RANGE_ERROR = createErrorSubclass('RangeError');\r\n  this.REFERENCE_ERROR = createErrorSubclass('ReferenceError');\r\n  this.SYNTAX_ERROR = createErrorSubclass('SyntaxError');\r\n  this.TYPE_ERROR = createErrorSubclass('TypeError');\r\n  this.URI_ERROR = createErrorSubclass('URIError');\r\n};\r\n\r\n/**\r\n * Initialize Math object.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initMath(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var myMath = this.createObjectProto(this.OBJECT_PROTO);\r\n  this.setProperty(scope, 'Math', myMath);\r\n  var mathConsts = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI',\r\n                    'SQRT1_2', 'SQRT2'];\r\n  for (var i = 0; i < mathConsts.length; i++) {\r\n    this.setProperty(myMath, mathConsts[i], Math[mathConsts[i]],\r\n        Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n  var numFunctions = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos',\r\n                      'exp', 'floor', 'log', 'max', 'min', 'pow', 'random',\r\n                      'round', 'sin', 'sqrt', 'tan'];\r\n  for (var i = 0; i < numFunctions.length; i++) {\r\n    this.setProperty(myMath, numFunctions[i],\r\n        this.createNativeFunction(Math[numFunctions[i]], false),\r\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n};\r\n\r\n/**\r\n * Initialize JSON object.\r\n * @param {!Interpreter.MyObject} scope Global scope.\r\n */\r\npublic initJSON(scope: Interpreter.MyObject) {\r\n  var thisInterpreter = this;\r\n  var myJSON = thisInterpreter.createObjectProto(this.OBJECT_PROTO);\r\n  this.setProperty(scope, 'JSON', myJSON);\r\n\r\n  var wrapper = function(text) {\r\n    try {\r\n      var nativeObj = JSON.parse(text.toString());\r\n    } catch (e) {\r\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, e.message);\r\n    }\r\n    return thisInterpreter.nativeToPseudo(nativeObj);\r\n  };\r\n  this.setProperty(myJSON, 'parse', this.createNativeFunction(wrapper, false));\r\n\r\n  wrapper = function(value) {\r\n    var nativeObj = thisInterpreter.pseudoToNative(value);\r\n    try {\r\n      var str = JSON.stringify(nativeObj);\r\n    } catch (e) {\r\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, e.message);\r\n    }\r\n    return str;\r\n  };\r\n  this.setProperty(myJSON, 'stringify',\r\n      this.createNativeFunction(wrapper, false));\r\n};\r\n\r\n/**\r\n * Is an object of a certain class?\r\n * @param {Interpreter.MyValue} child Object to check.\r\n * @param {Interpreter.MyObject} constructor Constructor of object.\r\n * @return {boolean} True if object is the class or inherits from it.\r\n *     False otherwise.\r\n */\r\npublic isa(child: Interpreter.MyValue, constructor: Interpreter.MyObject) {\r\n  if (child === null || child === undefined || !constructor) {\r\n    return false;\r\n  }\r\n  var proto = constructor.properties['prototype'];\r\n  if (child === proto) {\r\n    return true;\r\n  }\r\n  // The first step up the prototype chain is harder since the child might be\r\n  // a primitive value.  Subsequent steps can just follow the .proto property.\r\n  var childObj = this.getPrototype(child);\r\n  while (childObj) {\r\n    if (childObj === proto) {\r\n      return true;\r\n    }\r\n    childObj = childObj.proto;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Is a value a legal integer for an array length?\r\n * @param {Interpreter.MyValue} x Value to check.\r\n * @return {number} Zero, or a positive integer if the value can be\r\n *     converted to such.  NaN otherwise.\r\n */\r\nstatic legalArrayLength(x: Interpreter.MyValue) {\r\n  var n = <number>x >>> 0;\r\n  // Array length must be between 0 and 2^32-1 (inclusive).\r\n  return (n === Number(x)) ? n : NaN;\r\n};\r\n\r\n/**\r\n * Is a value a legal integer for an array index?\r\n * @param {Interpreter.MyValue} x Value to check.\r\n * @return {number} Zero, or a positive integer if the value can be\r\n *     converted to such.  NaN otherwise.\r\n */\r\nstatic legalArrayIndex(x: Interpreter.MyValue) {\r\n  var n = <number>x >>> 0;\r\n  // Array index cannot be 2^32-1, otherwise length would be 2^32.\r\n  // 0xffffffff is 2^32-1.\r\n  return (String(n) === String(x) && n !== 0xffffffff) ? n : NaN;\r\n};\r\n\r\n/**\r\n * Create a new data object based on a constructor's prototype.\r\n * @param {Interpreter.MyObject} constructor Parent constructor function,\r\n *     or null if scope object.\r\n * @return {!Interpreter.MyObject} New data object.\r\n */\r\npublic createObject(constructor: Interpreter.MyObject) {\r\n  return this.createObjectProto(constructor &&\r\n                                constructor.properties['prototype']);\r\n};\r\n\r\n/**\r\n * Create a new data object based on a prototype.\r\n * @param {Interpreter.MyObject} proto Prototype object.\r\n * @return {!Interpreter.MyObject} New data object.\r\n */\r\npublic createObjectProto(proto: Interpreter.MyObject) {\r\n  var obj = new Interpreter.MyObject(proto);\r\n  // Functions have prototype objects.\r\n  if (this.isa(obj, this.FUNCTION)) {\r\n    this.setProperty(obj, 'prototype',\r\n                     this.createObjectProto(this.OBJECT_PROTO || null));\r\n    obj.class = 'Function';\r\n  }\r\n  // Arrays have length.\r\n  if (this.isa(obj, this.ARRAY)) {\r\n    this.setProperty(obj, 'length', 0,\r\n        {configurable: false, enumerable: false, writable: true});\r\n    obj.class = 'Array';\r\n  }\r\n  if (this.isa(obj, this.ERROR)) {\r\n    obj.class = 'Error';\r\n  }\r\n  return obj;\r\n};\r\n\r\n/**\r\n * Initialize a pseudo regular expression object based on a native regular\r\n * expression object.\r\n * @param {!Interpreter.MyObject} pseudoRegexp The existing object to set.\r\n * @param {!RegExp} nativeRegexp The native regular expression.\r\n */\r\npublic populateRegExp(pseudoRegexp: Interpreter.MyObject, nativeRegexp: RegExp) {\r\n  pseudoRegexp.data = nativeRegexp;\r\n  // lastIndex is settable, all others are read-only attributes\r\n  this.setProperty(pseudoRegexp, 'lastIndex', nativeRegexp.lastIndex,\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(pseudoRegexp, 'source', nativeRegexp.source,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(pseudoRegexp, 'global', nativeRegexp.global,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(pseudoRegexp, 'ignoreCase', nativeRegexp.ignoreCase,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n  this.setProperty(pseudoRegexp, 'multiline', nativeRegexp.multiline,\r\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\r\n};\r\n\r\n/**\r\n * Create a new function.\r\n * @param {!Object} node AST node defining the function.\r\n * @param {!Object} scope Parent scope.\r\n * @return {!Interpreter.MyObject} New function.\r\n */\r\npublic createFunction(node: ESTree.FunctionDeclaration, scope: Interpreter.MyObject) {\r\n  var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n  func.parentScope = scope;\r\n  func.node = node;\r\n  this.setProperty(func, 'length', func.node['params'].length,\r\n      Interpreter.READONLY_DESCRIPTOR);\r\n  return func;\r\n};\r\n\r\n/**\r\n * Create a new native function.\r\n * @param {!Function} nativeFunc JavaScript function.\r\n * @param {boolean=} opt_constructor If true, the function's\r\n * prototype will have its constructor property set to the function.\r\n * If false, the function cannot be called as a constructor (e.g. escape).\r\n * Defaults to undefined.\r\n * @return {!Interpreter.MyObject} New function.\r\n */\r\npublic createNativeFunction(nativeFunc: NativeFunction, opt_constructor?: boolean) {\r\n  var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n  func.nativeFunc = nativeFunc;\r\n  nativeFunc.id = this.functionCounter_++;\r\n  this.setProperty(func, 'length', nativeFunc.length,\r\n      Interpreter.READONLY_DESCRIPTOR);\r\n  if (opt_constructor) {\r\n    this.setProperty(func.properties['prototype'], 'constructor',\r\n        func, Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  } else if (opt_constructor === false) {\r\n    func.illegalConstructor = true;\r\n    this.setProperty(func, 'prototype', undefined);\r\n  }\r\n  return func;\r\n};\r\n\r\n/**\r\n * Create a new native asynchronous function.\r\n * @param {!Function} asyncFunc JavaScript function.\r\n * @return {!Interpreter.MyObject} New function.\r\n */\r\npublic createAsyncFunction(asyncFunc) {\r\n  var func = this.createObjectProto(this.FUNCTION_PROTO);\r\n  func.asyncFunc = asyncFunc;\r\n  asyncFunc.id = this.functionCounter_++;\r\n  this.setProperty(func, 'length', asyncFunc.length,\r\n      Interpreter.READONLY_DESCRIPTOR);\r\n  return func;\r\n};\r\n\r\n/**\r\n * Converts from a native JS object or value to a JS interpreter object.\r\n * Can handle JSON-style values.\r\n * @param {*} nativeObj The native JS object to be converted.\r\n * @return {Interpreter.MyValue} The equivalent JS interpreter object.\r\n */\r\npublic nativeToPseudo(nativeObj: any): Interpreter.MyValue {\r\n  if (typeof nativeObj === 'boolean' ||\r\n      typeof nativeObj === 'number' ||\r\n      typeof nativeObj === 'string' ||\r\n      nativeObj === null || nativeObj === undefined) {\r\n    return nativeObj;\r\n  }\r\n\r\n  if (nativeObj instanceof RegExp) {\r\n    var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\r\n    this.populateRegExp(pseudoRegexp, nativeObj);\r\n    return pseudoRegexp;\r\n  }\r\n\r\n  if (nativeObj instanceof Function) {\r\n    var interpreter = this;\r\n    var wrapper = function() {\r\n      return interpreter.nativeToPseudo(\r\n        nativeObj.apply(interpreter,\r\n          Array.prototype.slice.call(arguments)\r\n          .map(function(i) {\r\n            return interpreter.pseudoToNative(i);\r\n          })\r\n        )\r\n      );\r\n    };\r\n    return this.createNativeFunction(wrapper, undefined);\r\n  }\r\n\r\n  var pseudoObj: Interpreter.MyObject;\r\n  if (Array.isArray(nativeObj)) {  // Array.\r\n    pseudoObj = this.createObjectProto(this.ARRAY_PROTO);\r\n    for (var i = 0; i < nativeObj.length; i++) {\r\n      if (i in nativeObj) {\r\n        this.setProperty(pseudoObj, i, this.nativeToPseudo(nativeObj[i]));\r\n      }\r\n    }\r\n  } else {  // Object.\r\n    pseudoObj = this.createObjectProto(this.OBJECT_PROTO);\r\n    for (var key in nativeObj) {\r\n      this.setProperty(pseudoObj, key, this.nativeToPseudo(nativeObj[key]));\r\n    }\r\n  }\r\n  return pseudoObj;\r\n};\r\n\r\n/**\r\n * Converts from a JS interpreter object to native JS object.\r\n * Can handle JSON-style values, plus cycles.\r\n * @param {Interpreter.MyValue} pseudoObj The JS interpreter object to be\r\n * converted.\r\n * @param {Object=} opt_cycles Cycle detection (used in recursive calls).\r\n * @return {*} The equivalent native JS object or value.\r\n */\r\npublic pseudoToNative(pseudoObj: Interpreter.MyValue, opt_cycles?: Interpreter.MyValueTable) {\r\n  if (typeof pseudoObj === 'boolean' ||\r\n      typeof pseudoObj === 'number' ||\r\n      typeof pseudoObj === 'string' ||\r\n      pseudoObj === null || pseudoObj === undefined) {\r\n    return pseudoObj;\r\n  }\r\n\r\n  if (this.isa(pseudoObj, this.REGEXP)) {  // Regular expression.\r\n    return pseudoObj.data;\r\n  }\r\n\r\n  var cycles = opt_cycles || {\r\n    pseudo: [],\r\n    native: []\r\n  };\r\n  var i = cycles.pseudo.indexOf(pseudoObj);\r\n  if (i !== -1) {\r\n    return cycles.native[i];\r\n  }\r\n  cycles.pseudo.push(pseudoObj);\r\n  var nativeObj;\r\n  if (this.isa(pseudoObj, this.ARRAY)) {  // Array.\r\n    nativeObj = [];\r\n    cycles.native.push(nativeObj);\r\n    var length = this.getProperty(pseudoObj, 'length');\r\n    for (var i = 0; i < length; i++) {\r\n      if (this.hasProperty(pseudoObj, i)) {\r\n        nativeObj[i] =\r\n            this.pseudoToNative(this.getProperty(pseudoObj, i), cycles);\r\n      }\r\n    }\r\n  } else {  // Object.\r\n    nativeObj = {};\r\n    cycles.native.push(nativeObj);\r\n    var val;\r\n    for (var key in pseudoObj.properties) {\r\n      val = pseudoObj.properties[key];\r\n      nativeObj[key] = this.pseudoToNative(val, cycles);\r\n    }\r\n  }\r\n  cycles.pseudo.pop();\r\n  cycles.native.pop();\r\n  return nativeObj;\r\n};\r\n\r\n/**\r\n * Look up the prototype for this value.\r\n * @param {Interpreter.MyValue} value Data object.\r\n * @return {Interpreter.MyObject} Prototype object, null if none.\r\n */\r\npublic getPrototype(value: Interpreter.MyValue): Interpreter.MyObject {\r\n  switch (typeof value) {\r\n    case 'number':\r\n      return this.NUMBER.properties['prototype'];\r\n    case 'boolean':\r\n      return this.BOOLEAN.properties['prototype'];\r\n    case 'string':\r\n      return this.STRING.properties['prototype'];\r\n  }\r\n  if (value) {\r\n    return (<Interpreter.MyObject>value).proto;\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Fetch a property value from a data object.\r\n * @param {Interpreter.MyValue} obj Data object.\r\n * @param {Interpreter.MyValue} name Name of property.\r\n * @return {Interpreter.MyValue} Property value (may be undefined).\r\n */\r\npublic getProperty(obj: Interpreter.MyValue, name: Interpreter.MyValue): Interpreter.MyValue {\r\n  name = String(name);\r\n  if (obj === undefined || obj === null) {\r\n    this.throwException(this.TYPE_ERROR,\r\n                        \"Cannot read property '\" + name + \"' of \" + obj);\r\n  }\r\n  if (name === 'length') {\r\n    // Special cases for magic length property.\r\n    if (this.isa(obj, this.STRING)) {\r\n      return String(obj).length;\r\n    }\r\n  } else if (name.charCodeAt(0) < 0x40) {\r\n    // Might have numbers in there?\r\n    // Special cases for string array indexing\r\n    if (this.isa(obj, this.STRING)) {\r\n      var n = Interpreter.legalArrayIndex(name);\r\n      if (!isNaN(n) && n < String(obj).length) {\r\n        return String(obj)[n];\r\n      }\r\n    }\r\n  }\r\n  do {\r\n    const myObj = <Interpreter.MyObject>obj;\r\n    if (myObj.properties && name in myObj.properties) {\r\n      var getter = myObj.getter[name];\r\n      if (getter) {\r\n        // Flag this function as being a getter and thus needing immediate\r\n        // execution (rather than being the value of the property).\r\n        getter.isGetter = true;\r\n        return getter;\r\n      }\r\n      return myObj.properties[name];\r\n    }\r\n  } while ((obj = this.getPrototype(obj)));\r\n  return undefined;\r\n};\r\n\r\n/**\r\n * Does the named property exist on a data object.\r\n * @param {Interpreter.MyValue} obj Data object.\r\n * @param {Interpreter.MyValue} name Name of property.\r\n * @return {boolean} True if property exists.\r\n */\r\npublic hasProperty(obj: Interpreter.MyValue, name: Interpreter.MyValue) {\r\n  if (!obj['isObject']) {\r\n    throw TypeError('Primitive data type has no properties');\r\n  }\r\n  name = String(name);\r\n  if (name === 'length' && this.isa(obj, this.STRING)) {\r\n    return true;\r\n  }\r\n  if (this.isa(obj, this.STRING)) {\r\n    var n = Interpreter.legalArrayIndex(name);\r\n    if (!isNaN(n) && n < String(obj).length) {\r\n      return true;\r\n    }\r\n  }\r\n  do {\r\n    const myObj = <Interpreter.MyObject> obj;\r\n    if (myObj.properties && name in myObj.properties) {\r\n      return true;\r\n    }\r\n  } while ((obj = this.getPrototype(obj)));\r\n  return false;\r\n};\r\n\r\n/**\r\n * Set a property value on a data object.\r\n * @param {!Interpreter.MyObject} obj Data object.\r\n * @param {Interpreter.MyValue} name Name of property.\r\n * @param {Interpreter.MyValue|ReferenceError} value New property value.\r\n *   Use ReferenceError if value is handled by descriptor instead.\r\n * @param {Object=} opt_descriptor Optional descriptor object.\r\n * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n *     needs to be called, otherwise undefined.\r\n */\r\npublic setProperty(obj: Interpreter.MyObject, name: Interpreter.MyValue, value: Interpreter.MyValue | ReferenceErrorConstructor, opt_descriptor?): Interpreter.MyObject {\r\n  name = String(name);\r\n  if (obj === undefined || obj === null) {\r\n    this.throwException(this.TYPE_ERROR,\r\n                        \"Cannot set property '\" + name + \"' of \" + obj);\r\n  }\r\n  if (opt_descriptor && ('get' in opt_descriptor || 'set' in opt_descriptor) &&\r\n      ('value' in opt_descriptor || 'writable' in opt_descriptor)) {\r\n    this.throwException(this.TYPE_ERROR, 'Invalid property descriptor. ' +\r\n        'Cannot both specify accessors and a value or writable attribute');\r\n  }\r\n  var strict = !this.stateStack || this.getScope().strict;\r\n  if (!obj.isObject) {\r\n    if (strict) {\r\n      this.throwException(this.TYPE_ERROR, \"Can't create property '\" + name +\r\n                          \"' on '\" + obj + \"'\");\r\n    }\r\n    return;\r\n  }\r\n  if (this.isa(obj, this.STRING)) {\r\n    var n = Interpreter.legalArrayIndex(name);\r\n    if (name === 'length' || (!isNaN(n) && n < String(obj).length)) {\r\n      // Can't set length or letters on String objects.\r\n      if (strict) {\r\n        this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\r\n            \"property '\" + name + \"' of String '\" + obj.data + \"'\");\r\n      }\r\n      return;\r\n    }\r\n  }\r\n  if (obj.class === 'Array') {\r\n    // Arrays have a magic length variable that is bound to the elements.\r\n    var length = obj.properties.length;\r\n    var i;\r\n    if (name === 'length') {\r\n      // Delete elements if length is smaller.\r\n      value = Interpreter.legalArrayLength(<number>value);\r\n      if (isNaN(value)) {\r\n        this.throwException(this.RANGE_ERROR, 'Invalid array length');\r\n      }\r\n      if (value < length) {\r\n        for (i in obj.properties) {\r\n          i = Interpreter.legalArrayIndex(i);\r\n          if (!isNaN(i) && value <= i) {\r\n            delete obj.properties[i];\r\n          }\r\n        }\r\n      }\r\n    } else if (!isNaN(i = Interpreter.legalArrayIndex(name))) {\r\n      // Increase length if this index is larger.\r\n      obj.properties.length = Math.max(length, i + 1);\r\n    }\r\n  }\r\n  if (obj.preventExtensions && !(name in obj.properties)) {\r\n    if (strict) {\r\n      this.throwException(this.TYPE_ERROR, \"Can't add property '\" + name +\r\n                          \"', object is not extensible\");\r\n    }\r\n    return;\r\n  }\r\n  if (opt_descriptor) {\r\n    // Define the property.\r\n    if ('get' in opt_descriptor) {\r\n      if (opt_descriptor.get) {\r\n        obj.getter[name] = opt_descriptor.get;\r\n      } else {\r\n        delete obj.getter[name];\r\n      }\r\n    }\r\n    if ('set' in opt_descriptor) {\r\n      if (opt_descriptor.set) {\r\n        obj.setter[name] = opt_descriptor.set;\r\n      } else {\r\n        delete obj.setter[name];\r\n      }\r\n    }\r\n    var descriptor: {\r\n      configurable?: boolean;\r\n      enumerable?: boolean;\r\n      writable?: boolean;\r\n      value?: any;\r\n    } = {};\r\n    if ('configurable' in opt_descriptor) {\r\n      descriptor.configurable = opt_descriptor.configurable;\r\n    }\r\n    if ('enumerable' in opt_descriptor) {\r\n      descriptor.enumerable = opt_descriptor.enumerable;\r\n    }\r\n    if ('writable' in opt_descriptor) {\r\n      descriptor.writable = opt_descriptor.writable;\r\n      delete obj.getter[name];\r\n      delete obj.setter[name];\r\n    }\r\n    if ('value' in opt_descriptor) {\r\n      descriptor.value = opt_descriptor.value;\r\n      delete obj.getter[name];\r\n      delete obj.setter[name];\r\n    } else if (value !== ReferenceError) {\r\n      descriptor.value = value;\r\n      delete obj.getter[name];\r\n      delete obj.setter[name];\r\n    }\r\n    try {\r\n      Object.defineProperty(obj.properties, name, descriptor);\r\n    } catch (e) {\r\n      this.throwException(this.TYPE_ERROR, 'Cannot redefine property: ' + name);\r\n    }\r\n  } else {\r\n    // Set the property.\r\n    if (value === ReferenceError) {\r\n      throw ReferenceError('Value not specified.');\r\n    }\r\n    // Determine the parent (possibly self) where the property is defined.\r\n    var defObj = obj;\r\n    while (!(name in defObj.properties)) {\r\n      defObj = this.getPrototype(defObj);\r\n      if (!defObj) {\r\n        // This is a new property.\r\n        defObj = obj;\r\n        break;\r\n      }\r\n    }\r\n    if (defObj.setter && defObj.setter[name]) {\r\n      return defObj.setter[name];\r\n    }\r\n    if (defObj.getter && defObj.getter[name]) {\r\n      if (strict) {\r\n        this.throwException(this.TYPE_ERROR, \"Cannot set property '\" + name +\r\n            \"' of object '\" + obj + \"' which only has a getter\");\r\n      }\r\n    } else {\r\n      // No setter, simple assignment.\r\n      try {\r\n        obj.properties[name] = value;\r\n      } catch (e) {\r\n        if (strict) {\r\n          this.throwException(this.TYPE_ERROR, \"Cannot assign to read only \" +\r\n              \"property '\" + name + \"' of object '\" + obj + \"'\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Convenience method for adding a native function as a non-enumerable property\r\n * onto an object's prototype.\r\n * @param {!Interpreter.MyObject} obj Data object.\r\n * @param {Interpreter.MyValue} name Name of property.\r\n * @param {!Function} wrapper Function object.\r\n */\r\nprivate setNativeFunctionPrototype(obj: Interpreter.MyObject, name: Interpreter.MyValue, wrapper: Function) {\r\n  this.setProperty(obj.properties['prototype'], name,\r\n      this.createNativeFunction(wrapper, false),\r\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n};\r\n\r\n/**\r\n * Returns the current scope from the stateStack.\r\n * @return {!Interpreter.MyObject} Current scope dictionary.\r\n */\r\npublic getScope() {\r\n  var scope = this.stateStack[this.stateStack.length - 1].scope;\r\n  if (!scope) {\r\n    throw Error('No scope found.');\r\n  }\r\n  return scope;\r\n};\r\n\r\n/**\r\n * Create a new scope dictionary.\r\n * @param {!Object} node AST node defining the scope container\r\n *     (e.g. a function).\r\n * @param {Interpreter.MyObject} parentScope Scope to link to.\r\n * @return {!Interpreter.MyObject} New scope.\r\n */\r\npublic createScope(node: ESTree.Node, parentScope: Interpreter.MyObject) {\r\n  var scope = this.createObjectProto(null);\r\n  scope.parentScope = parentScope;\r\n  if (!parentScope) {\r\n    this.initGlobalScope(scope);\r\n  }\r\n  this.populateScope_(node, scope);\r\n\r\n  // Determine if this scope starts with 'use strict'.\r\n  scope.strict = false;\r\n  if (parentScope && parentScope.strict) {\r\n    scope.strict = true;\r\n  } else {\r\n    var firstNode = node['body'] && node['body'][0];\r\n    if (firstNode && firstNode.expression &&\r\n        firstNode.expression['type'] === 'Literal' &&\r\n        firstNode.expression.value === 'use strict') {\r\n      scope.strict = true;\r\n    }\r\n  }\r\n  return scope;\r\n};\r\n\r\n/**\r\n * Create a new special scope dictionary. Similar to createScope(), but\r\n * doesn't assume that the scope is for a function body.\r\n * This is used for 'catch' clauses and 'with' statements.\r\n * @param {!Interpreter.MyObject} parentScope Scope to link to.\r\n * @param {Interpreter.MyObject=} opt_scope Optional object to transform into\r\n *     scope.\r\n * @return {!Interpreter.MyObject} New scope.\r\n */\r\npublic createSpecialScope(parentScope: Interpreter.MyObject, opt_scope?: Interpreter.MyObject) {\r\n  if (!parentScope) {\r\n    throw Error('parentScope required');\r\n  }\r\n  var scope = opt_scope || this.createObjectProto(null);\r\n  scope.parentScope = parentScope;\r\n  scope.strict = parentScope.strict;\r\n  return scope;\r\n};\r\n\r\n/**\r\n * Retrieves a value from the scope chain.\r\n * @param {string} name Name of variable.\r\n * @return {Interpreter.MyValue} Any value.\r\n *   May be flagged as being a getter and thus needing immediate execution\r\n *   (rather than being the value of the property).\r\n */\r\npublic getValueFromScope(name: string): Interpreter.MyValue {\r\n  var scope = this.getScope();\r\n  while (scope && scope !== this.global) {\r\n    if (name in scope.properties) {\r\n      return scope.properties[name];\r\n    }\r\n    scope = scope.parentScope;\r\n  }\r\n  // The root scope is also an object which has inherited properties and\r\n  // could also have getters.\r\n  if (scope === this.global && this.hasProperty(scope, name)) {\r\n    return this.getProperty(scope, name);\r\n  }\r\n  // Typeof operator is unique: it can safely look at non-defined variables.\r\n  var prevNode = this.stateStack[this.stateStack.length - 1].node;\r\n  if (prevNode['type'] === 'UnaryExpression' &&\r\n      prevNode['operator'] === 'typeof') {\r\n    return undefined;\r\n  }\r\n  this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\r\n};\r\n\r\n/**\r\n * Sets a value to the current scope.\r\n * @param {string} name Name of variable.\r\n * @param {Interpreter.MyValue} value Value.\r\n * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n *     needs to be called, otherwise undefined.\r\n */\r\npublic setValueToScope(name: string, value: Interpreter.MyValue) {\r\n  var scope = this.getScope();\r\n  var strict = scope.strict;\r\n  while (scope && scope !== this.global) {\r\n    if (name in scope.properties) {\r\n      scope.properties[name] = value;\r\n      return undefined;\r\n    }\r\n    scope = scope.parentScope;\r\n  }\r\n  // The root scope is also an object which has readonly properties and\r\n  // could also have setters.\r\n  if (scope === this.global && (!strict || this.hasProperty(scope, name))) {\r\n    return this.setProperty(scope, name, value);\r\n  }\r\n  this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\r\n};\r\n\r\n/**\r\n * Create a new scope for the given node.\r\n * @param {!Object} node AST node (program or function).\r\n * @param {!Interpreter.MyObject} scope Scope dictionary to populate.\r\n * @private\r\n */\r\npublic populateScope_(node: ESTree.Node, scope: Interpreter.MyObject) {\r\n  if (node['type'] === 'VariableDeclaration') {\r\n    for (var i = 0; i < node['declarations'].length; i++) {\r\n      this.setProperty(scope, node['declarations'][i]['id']['name'],\r\n          undefined, Interpreter.VARIABLE_DESCRIPTOR);\r\n    }\r\n  } else if (node['type'] === 'FunctionDeclaration') {\r\n    this.setProperty(scope, node['id']['name'],\r\n        this.createFunction(<ESTree.FunctionDeclaration>node, scope), Interpreter.VARIABLE_DESCRIPTOR);\r\n    return;  // Do not recurse into function.\r\n  } else if (node['type'] === 'FunctionExpression') {\r\n    return;  // Do not recurse into function.\r\n  } else if (node['type'] === 'ExpressionStatement') {\r\n    return;  // Expressions can't contain variable/function declarations.\r\n  }\r\n  var nodeClass = node['constructor'];\r\n  for (var name in node) {\r\n    var prop = node[name];\r\n    if (prop && typeof prop === 'object') {\r\n      if (Array.isArray(prop)) {\r\n        for (var i = 0; i < prop.length; i++) {\r\n          if (prop[i] && prop[i].constructor === nodeClass) {\r\n            this.populateScope_(prop[i], scope);\r\n          }\r\n        }\r\n      } else {\r\n        if (prop.constructor === nodeClass) {\r\n          this.populateScope_(prop, scope);\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Remove start and end values from AST, or set start and end values to a\r\n * constant value.  Used to remove highlighting from polyfills and to set\r\n * highlighting in an eval to cover the entire eval expression.\r\n * @param {!Object} node AST node.\r\n * @param {number=} start Starting character of all nodes, or undefined.\r\n * @param {number=} end Ending character of all nodes, or undefined.\r\n * @private\r\n */\r\nprivate stripLocations_(node: ESTree.BaseNode, start: number, end: number) {\r\n  if (start) {\r\n    node['start'] = start;\r\n  } else {\r\n    delete node['start'];\r\n  }\r\n  if (end) {\r\n    node['end'] = end;\r\n  } else {\r\n    delete node['end'];\r\n  }\r\n  for (var name in node) {\r\n    if (node.hasOwnProperty(name)) {\r\n      var prop = node[name];\r\n      if (prop && typeof prop === 'object') {\r\n        this.stripLocations_(prop, start, end);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Is the current state directly being called with as a construction with 'new'.\r\n * @return {boolean} True if 'new foo()', false if 'foo()'.\r\n */\r\npublic calledWithNew(): boolean {\r\n  return this.stateStack[this.stateStack.length - 1].isConstructor;\r\n};\r\n\r\n/**\r\n * Gets a value from the scope chain or from an object property.\r\n * @param {!Array} ref Name of variable or object/propname tuple.\r\n * @return {Interpreter.MyValue} Any value.\r\n *   May be flagged as being a getter and thus needing immediate execution\r\n *   (rather than being the value of the property).\r\n */\r\npublic getValue(ref) {\r\n  if (ref[0] === Interpreter.SCOPE_REFERENCE) {\r\n    // A null/varname variable lookup.\r\n    return this.getValueFromScope(ref[1]);\r\n  } else {\r\n    // An obj/prop components tuple (foo.bar).\r\n    return this.getProperty(ref[0], ref[1]);\r\n  }\r\n};\r\n\r\n/**\r\n * Sets a value to the scope chain or to an object property.\r\n * @param {!Array} ref Name of variable or object/propname tuple.\r\n * @param {Interpreter.MyValue} value Value.\r\n * @return {!Interpreter.MyObject|undefined} Returns a setter function if one\r\n *     needs to be called, otherwise undefined.\r\n */\r\npublic setValue(ref: Array<any> & { 0: Interpreter.MyObject, 1: string }, value: Interpreter.MyValue) {\r\n  if (ref[0] === Interpreter.SCOPE_REFERENCE) {\r\n    // A null/varname variable lookup.\r\n    return this.setValueToScope(ref[1], value);\r\n  } else {\r\n    // An obj/prop components tuple (foo.bar).\r\n    return this.setProperty(ref[0], ref[1], value);\r\n  }\r\n};\r\n\r\n/**\r\n * Throw an exception in the interpreter that can be handled by an\r\n * interpreter try/catch statement.  If unhandled, a real exception will\r\n * be thrown.  Can be called with either an error class and a message, or\r\n * with an actual object to be thrown.\r\n * @param {!Interpreter.MyObject} errorClass Type of error (if message is\r\n *   provided) or the value to throw (if no message).\r\n * @param {string=} opt_message Message being thrown.\r\n */\r\npublic throwException(errorClass: Interpreter.MyObject, opt_message?: string) {\r\n  if (opt_message === undefined) {\r\n    var error = <Interpreter.MyObject>errorClass;  // This is a value to throw, not an error class.\r\n  } else {\r\n    var error = this.createObject(errorClass);\r\n    this.setProperty(error, 'message', opt_message,\r\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\r\n  }\r\n  this.executeException(error);\r\n  // Abort anything related to the current step.\r\n  throw Interpreter.STEP_ERROR;\r\n};\r\n\r\n/**\r\n * Throw an exception in the interpreter that can be handled by a\r\n * interpreter try/catch statement.  If unhandled, a real exception will\r\n * be thrown.\r\n * @param {!Interpreter.MyObject} error Error object to execute.\r\n */\r\npublic executeException(error: Interpreter.MyObject) {\r\n  // Search for a try statement.\r\n  do {\r\n    this.stateStack.pop();\r\n    var state = this.stateStack[this.stateStack.length - 1];\r\n    if (state.node['type'] === 'TryStatement') {\r\n      state.throwValue = error;\r\n      return;\r\n    }\r\n  } while (state && state.node['type'] !== 'Program');\r\n\r\n  // Throw a real error.\r\n  var realError;\r\n  if (this.isa(error, this.ERROR)) {\r\n    var errorTable = {\r\n      'EvalError': EvalError,\r\n      'RangeError': RangeError,\r\n      'ReferenceError': ReferenceError,\r\n      'SyntaxError': SyntaxError,\r\n      'TypeError': TypeError,\r\n      'URIError': URIError\r\n    };\r\n    var name = this.getProperty(error, 'name').toString();\r\n    var message = this.getProperty(error, 'message').valueOf();\r\n    var type = errorTable[name] || Error;\r\n    realError = type(message);\r\n  } else {\r\n    realError = error.toString();\r\n  }\r\n  throw realError;\r\n};\r\n\r\n/**\r\n * Create a call to a getter function.\r\n * @param {!Interpreter.MyObject} func Function to execute.\r\n * @param {!Interpreter.MyObject|!Array} left\r\n *     Name of variable or object/propname tuple.\r\n * @private\r\n */\r\npublic createGetter_(func: Interpreter.MyObject, left: Interpreter.MyObject | Array<Interpreter.MyObject>) {\r\n  // Normally 'this' will be specified as the object component (o.x).\r\n  // Sometimes 'this' is explicitly provided (o).\r\n  var funcThis = Array.isArray(left) ? left[0] : left;\r\n  var node = new this.nodeConstructor();\r\n  node['type'] = 'CallExpression';\r\n  var state = new Interpreter.MyState(node,\r\n      this.stateStack[this.stateStack.length - 1].scope);\r\n  state.doneCallee_ = true;\r\n  state.funcThis_ = funcThis;\r\n  state.func_ = func;\r\n  state.doneArgs_ = true;\r\n  state.arguments_ = [];\r\n  return state;\r\n};\r\n\r\n/**\r\n * Create a call to a setter function.\r\n * @param {!Interpreter.MyObject} func Function to execute.\r\n * @param {!Interpreter.MyObject|!Array} left\r\n *     Name of variable or object/propname tuple.\r\n * @param {Interpreter.MyValue} value Value to set.\r\n * @private\r\n */\r\npublic createSetter_(func: Interpreter.MyObject, left: Interpreter.MyObject | Array<Interpreter.MyObject>, value: Interpreter.MyValue) {\r\n  // Normally 'this' will be specified as the object component (o.x).\r\n  // Sometimes 'this' is implicitly the global object (x).\r\n  var funcThis = Array.isArray(left) ? left[0] : this.global;\r\n  var node = new this.nodeConstructor();\r\n  node['type'] = 'CallExpression';\r\n  var state = new Interpreter.MyState(node,\r\n      this.stateStack[this.stateStack.length - 1].scope);\r\n  state.doneCallee_ = true;\r\n  state.funcThis_ = funcThis;\r\n  state.func_ = func;\r\n  state.doneArgs_ = true;\r\n  state.arguments_ = [value];\r\n  return state;\r\n};\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Functions to handle each node type.\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nprivate stepArrayExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var elements = node['elements'];\r\n  var n = state.n_ || 0;\r\n  if (!state.array_) {\r\n    state.array_ = this.createObjectProto(this.ARRAY_PROTO);\r\n    state.array_.properties.length = elements.length;\r\n  } else {\r\n    this.setProperty(state.array_, n, state.value);\r\n    n++;\r\n  }\r\n  while (n < elements.length) {\r\n    // Skip missing elements - they're not defined, not undefined.\r\n    if (elements[n]) {\r\n      state.n_ = n;\r\n      return new Interpreter.MyState(elements[n], state.scope);\r\n    }\r\n    n++;\r\n  }\r\n  stack.pop();\r\n  stack[stack.length - 1].value = state.array_;\r\n};\r\n\r\nprivate stepAssignmentExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneLeft_) {\r\n    state.doneLeft_ = true;\r\n    var nextState = new Interpreter.MyState(node['left'], state.scope);\r\n    nextState.components = true;\r\n    return nextState;\r\n  }\r\n  if (!state.doneRight_) {\r\n    if (!state.leftReference_) {\r\n      state.leftReference_ = state.value;\r\n    }\r\n    if (state.doneGetter_) {\r\n      state.leftValue_ = state.value;\r\n    }\r\n    if (!state.doneGetter_ && node['operator'] !== '=') {\r\n      var leftValue = this.getValue(state.leftReference_);\r\n      state.leftValue_ = leftValue;\r\n      if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\r\n        // Clear the getter flag and call the getter function.\r\n        leftValue.isGetter = false;\r\n        state.doneGetter_ = true;\r\n        var func = /** @type {!Interpreter.Object} */ (leftValue);\r\n        return this.createGetter_(func, state.leftReference_);\r\n      }\r\n    }\r\n    state.doneRight_ = true;\r\n    return new Interpreter.MyState(node['right'], state.scope);\r\n  }\r\n  if (state.doneSetter_) {\r\n    // Return if setter function.\r\n    // Setter method on property has completed.\r\n    // Ignore its return value, and use the original set value instead.\r\n    stack.pop();\r\n    stack[stack.length - 1].value = state.doneSetter_;\r\n    return;\r\n  }\r\n  var value = state.leftValue_;\r\n  var rightValue = state.value;\r\n  switch (node['operator']) {\r\n    case '=':    value =    rightValue; break;\r\n    case '+=':   value +=   rightValue; break;\r\n    case '-=':   value -=   rightValue; break;\r\n    case '*=':   value *=   rightValue; break;\r\n    case '/=':   value /=   rightValue; break;\r\n    case '%=':   value %=   rightValue; break;\r\n    case '<<=':  value <<=  rightValue; break;\r\n    case '>>=':  value >>=  rightValue; break;\r\n    case '>>>=': value >>>= rightValue; break;\r\n    case '&=':   value &=   rightValue; break;\r\n    case '^=':   value ^=   rightValue; break;\r\n    case '|=':   value |=   rightValue; break;\r\n    default:\r\n      throw SyntaxError('Unknown assignment expression: ' + node['operator']);\r\n  }\r\n  var setter = this.setValue(state.leftReference_, value);\r\n  if (setter) {\r\n    state.doneSetter_ = value;\r\n    return this.createSetter_(setter, state.leftReference_, value);\r\n  }\r\n  // Return if no setter function.\r\n  stack.pop();\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepBinaryExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneLeft_) {\r\n    state.doneLeft_ = true;\r\n    return new Interpreter.MyState(node['left'], state.scope);\r\n  }\r\n  if (!state.doneRight_) {\r\n    state.doneRight_ = true;\r\n    state.leftValue_ = state.value;\r\n    return new Interpreter.MyState(node['right'], state.scope);\r\n  }\r\n  stack.pop();\r\n  var leftValue = state.leftValue_;\r\n  var rightValue = state.value;\r\n  var value;\r\n  switch (node['operator']) {\r\n    case '==':  value = leftValue ==  rightValue; break;\r\n    case '!=':  value = leftValue !=  rightValue; break;\r\n    case '===': value = leftValue === rightValue; break;\r\n    case '!==': value = leftValue !== rightValue; break;\r\n    case '>':   value = leftValue >   rightValue; break;\r\n    case '>=':  value = leftValue >=  rightValue; break;\r\n    case '<':   value = leftValue <   rightValue; break;\r\n    case '<=':  value = leftValue <=  rightValue; break;\r\n    case '+':   value = leftValue +   rightValue; break;\r\n    case '-':   value = leftValue -   rightValue; break;\r\n    case '*':   value = leftValue *   rightValue; break;\r\n    case '/':   value = leftValue /   rightValue; break;\r\n    case '%':   value = leftValue %   rightValue; break;\r\n    case '&':   value = leftValue &   rightValue; break;\r\n    case '|':   value = leftValue |   rightValue; break;\r\n    case '^':   value = leftValue ^   rightValue; break;\r\n    case '<<':  value = leftValue <<  rightValue; break;\r\n    case '>>':  value = leftValue >>  rightValue; break;\r\n    case '>>>': value = leftValue >>> rightValue; break;\r\n    case 'in':\r\n      if (!rightValue || !rightValue.isObject) {\r\n        this.throwException(this.TYPE_ERROR,\r\n            \"'in' expects an object, not '\" + rightValue + \"'\");\r\n      }\r\n      value = this.hasProperty(rightValue, leftValue);\r\n      break;\r\n    case 'instanceof':\r\n      if (!this.isa(rightValue, this.FUNCTION)) {\r\n        this.throwException(this.TYPE_ERROR,\r\n            'Right-hand side of instanceof is not an object');\r\n      }\r\n      value = leftValue.isObject ? this.isa(leftValue, rightValue) : false;\r\n      break;\r\n    default:\r\n      throw SyntaxError('Unknown binary operator: ' + node['operator']);\r\n  }\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepBlockStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var expression = node['body'][n];\r\n  if (expression) {\r\n    state.n_ = n + 1;\r\n    return new Interpreter.MyState(expression, state.scope);\r\n  }\r\n  stack.pop();\r\n};\r\n\r\nprivate stepBreakStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  var label = null;\r\n  if (node['label']) {\r\n    label = node['label']['name'];\r\n  }\r\n  while (state &&\r\n         state.node['type'] !== 'CallExpression' &&\r\n         state.node['type'] !== 'NewExpression') {\r\n    if (label) {\r\n      if (state.labels && state.labels.indexOf(label) !== -1) {\r\n        return;\r\n      }\r\n    } else if (state.isLoop || state.isSwitch) {\r\n      return;\r\n    }\r\n    state = stack.pop();\r\n  }\r\n  // Syntax error, do not allow this error to be trapped.\r\n  throw SyntaxError('Illegal break statement');\r\n};\r\n\r\nprivate stepCallExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneCallee_) {\r\n    state.doneCallee_ = 1;\r\n    // Components needed to determine value of 'this'.\r\n    var nextState = new Interpreter.MyState(node['callee'], state.scope);\r\n    nextState.components = true;\r\n    return nextState;\r\n  }\r\n  if (state.doneCallee_ === 1) {\r\n    // Determine value of the function.\r\n    state.doneCallee_ = 2;\r\n    var func = state.value;\r\n    if (Array.isArray(func)) {\r\n      state.func_ = this.getValue(func);\r\n      if (func[0] !== Interpreter.SCOPE_REFERENCE) {\r\n        // Method function, 'this' is object (ignored if invoked as 'new').\r\n        state.funcThis_ = func[0];\r\n      }\r\n      func = state.func_;\r\n      if (func && typeof func === 'object' && func.isGetter) {\r\n        // Clear the getter flag and call the getter function.\r\n        func.isGetter = false;\r\n        state.doneCallee_ = 1;\r\n        return this.createGetter_(/** @type {!Interpreter.Object} */ (func),\r\n                         state.value);\r\n      }\r\n    } else {\r\n      // Already evaluated function: (function(){...})();\r\n      state.func_ = func;\r\n    }\r\n    state.arguments_ = [];\r\n    state.n_ = 0;\r\n  }\r\n  var func = state.func_;\r\n  if (!state.doneArgs_) {\r\n    if (state.n_ !== 0) {\r\n      state.arguments_.push(state.value);\r\n    }\r\n    if (node['arguments'][state.n_]) {\r\n      return new Interpreter.MyState(node['arguments'][state.n_++], state.scope);\r\n    }\r\n    // Determine value of 'this' in function.\r\n    if (node['type'] === 'NewExpression') {\r\n      if (func.illegalConstructor) {\r\n        // Illegal: new escape();\r\n        this.throwException(this.TYPE_ERROR, func + ' is not a constructor');\r\n      }\r\n      // Constructor, 'this' is new object.\r\n      state.funcThis_ = this.createObject(func);\r\n      state.isConstructor = true;\r\n    } else if (state.funcThis_ === undefined) {\r\n      // Global function, 'this' is global object (or 'undefined' if strict).\r\n      state.funcThis_ = state.scope.strict ? undefined : this.global;\r\n    }\r\n    state.doneArgs_ = true;\r\n  }\r\n  if (!state.doneExec_) {\r\n    state.doneExec_ = true;\r\n    if (!func || !func.isObject) {\r\n      this.throwException(this.TYPE_ERROR, func + ' is not a function');\r\n    }\r\n    var funcNode = func.node;\r\n    if (funcNode) {\r\n      var scope = this.createScope(funcNode['body'], func.parentScope);\r\n      // Add all arguments.\r\n      for (var i = 0; i < funcNode['params'].length; i++) {\r\n        var paramName = funcNode['params'][i]['name'];\r\n        var paramValue = state.arguments_.length > i ? state.arguments_[i] :\r\n            undefined;\r\n        this.setProperty(scope, paramName, paramValue);\r\n      }\r\n      // Build arguments variable.\r\n      var argsList = this.createObjectProto(this.ARRAY_PROTO);\r\n      for (var i = 0; i < state.arguments_.length; i++) {\r\n        this.setProperty(argsList, i, state.arguments_[i]);\r\n      }\r\n      this.setProperty(scope, 'arguments', argsList);\r\n      // Add the function's name (var x = function foo(){};)\r\n      var name = funcNode['id'] && funcNode['id']['name'];\r\n      if (name) {\r\n        this.setProperty(scope, name, func);\r\n      }\r\n      this.setProperty(scope, 'this', state.funcThis_,\r\n                       Interpreter.READONLY_DESCRIPTOR);\r\n      state.value = undefined;  // Default value if no explicit return.\r\n      return new Interpreter.MyState(funcNode['body'], scope);\r\n    } else if (func.eval) {\r\n      var code = state.arguments_[0];\r\n      if (typeof code !== 'string') {\r\n        // JS does not parse String objects:\r\n        // eval(new String('1 + 1')) -> '1 + 1'\r\n        state.value = code;\r\n      } else {\r\n        try {\r\n          var ast = acorn.parse(code.toString(), Interpreter.PARSE_OPTIONS);\r\n        } catch (e) {\r\n          // Acorn threw a SyntaxError.  Rethrow as a trappable error.\r\n          this.throwException(this.SYNTAX_ERROR, 'Invalid code: ' + e.message);\r\n        }\r\n        var evalNode = new this.nodeConstructor();\r\n        evalNode['type'] = 'EvalProgram_';\r\n        evalNode['body'] = ast['body'];\r\n        this.stripLocations_(evalNode, node['start'], node['end']);\r\n        // Update current scope with definitions in eval().\r\n        var scope = <Interpreter.MyObject>state.scope;\r\n        if (scope.strict) {\r\n          // Strict mode get its own scope in eval.\r\n          scope = this.createScope(ast, scope);\r\n        } else {\r\n          // Non-strict mode pollutes the current scope.\r\n          this.populateScope_(ast, scope);\r\n        }\r\n        this.value = undefined;  // Default value if no code.\r\n        return new Interpreter.MyState(evalNode, scope);\r\n      }\r\n    } else if (func.nativeFunc) {\r\n      state.value = func.nativeFunc.apply(state.funcThis_, state.arguments_);\r\n    } else if (func.asyncFunc) {\r\n      var thisInterpreter = this;\r\n      var callback = function(value) {\r\n        state.value = value;\r\n        thisInterpreter.paused_ = false;\r\n      };\r\n      var argsWithCallback = state.arguments_.concat(callback);\r\n      this.paused_ = true;\r\n      func.asyncFunc.apply(state.funcThis_, argsWithCallback);\r\n      return;\r\n    } else {\r\n      /* A child of a function is a function but is not callable.  For example:\r\n      var F = function() {};\r\n      F.prototype = escape;\r\n      var f = new F();\r\n      f();\r\n      */\r\n      this.throwException(this.TYPE_ERROR, func.class + ' is not a function');\r\n    }\r\n  } else {\r\n    // Execution complete.  Put the return value on the stack.\r\n    stack.pop();\r\n    if (state.isConstructor && typeof state.value !== 'object') {\r\n      stack[stack.length - 1].value = state.funcThis_;\r\n    } else {\r\n      stack[stack.length - 1].value = state.value;\r\n    }\r\n  }\r\n};\r\n\r\nprivate stepCatchClause(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.done_) {\r\n    state.done_ = true;\r\n    // Create an empty scope.\r\n    var scope = this.createSpecialScope(state.scope);\r\n    // Add the argument.\r\n    this.setProperty(scope, node['param']['name'], state.throwValue);\r\n    // Execute catch clause.\r\n    return new Interpreter.MyState(node['body'], scope);\r\n  } else {\r\n    stack.pop();\r\n  }\r\n};\r\n\r\nprivate stepConditionalExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var mode = state.mode_ || 0;\r\n  if (mode === 0) {\r\n    state.mode_ = 1;\r\n    return new Interpreter.MyState(node['test'], state.scope);\r\n  }\r\n  if (mode === 1) {\r\n    state.mode_ = 2;\r\n    var value = Boolean(state.value);\r\n    if (value && node['consequent']) {\r\n      // Execute 'if' block.\r\n      return new Interpreter.MyState(node['consequent'], state.scope);\r\n    } else if (!value && node['alternate']) {\r\n      // Execute 'else' block.\r\n      return new Interpreter.MyState(node['alternate'], state.scope);\r\n    }\r\n    // eval('1;if(false){2}') -> undefined\r\n    this.value = undefined;\r\n  }\r\n  stack.pop();\r\n  if (node['type'] === 'ConditionalExpression') {\r\n    stack[stack.length - 1].value = state.value;\r\n  }\r\n};\r\n\r\nprivate stepContinueStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  var label = null;\r\n  if (node['label']) {\r\n    label = node['label']['name'];\r\n  }\r\n  state = stack[stack.length - 1];\r\n  while (state &&\r\n         state.node['type'] !== 'CallExpression' &&\r\n         state.node['type'] !== 'NewExpression') {\r\n    if (state.isLoop) {\r\n      if (!label || (state.labels && state.labels.indexOf(label) !== -1)) {\r\n        return;\r\n      }\r\n    }\r\n    stack.pop();\r\n    state = stack[stack.length - 1];\r\n  }\r\n  // Syntax error, do not allow this error to be trapped.\r\n  throw SyntaxError('Illegal continue statement');\r\n};\r\n\r\nprivate stepDebuggerStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  // Do nothing.  May be overridden by developers.\r\n  stack.pop();\r\n};\r\n\r\nprivate stepDoWhileStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (node['type'] === 'DoWhileStatement' && state.test_ === undefined) {\r\n    // First iteration of do/while executes without checking test.\r\n    state.value = true;\r\n    state.test_ = true;\r\n  }\r\n  if (!state.test_) {\r\n    state.test_ = true;\r\n    return new Interpreter.MyState(node['test'], state.scope);\r\n  }\r\n  if (!state.value) {  // Done, exit loop.\r\n    stack.pop();\r\n  } else if (node['body']) {  // Execute the body.\r\n    state.test_ = false;\r\n    state.isLoop = true;\r\n    return new Interpreter.MyState(node['body'], state.scope);\r\n  }\r\n};\r\n\r\nprivate stepEmptyStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n};\r\n\r\nprivate stepEvalProgram_(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var expression = node['body'][n];\r\n  if (expression) {\r\n    state.n_ = n + 1;\r\n    return new Interpreter.MyState(expression, state.scope);\r\n  }\r\n  stack.pop();\r\n  stack[stack.length - 1].value = this.value;\r\n};\r\n\r\nprivate stepExpressionStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.done_) {\r\n    state.done_ = true;\r\n    return new Interpreter.MyState(node['expression'], state.scope);\r\n  }\r\n  stack.pop();\r\n  // Save this value to interpreter.value for use as a return value if\r\n  // this code is inside an eval function.\r\n  this.value = state.value;\r\n};\r\n\r\nprivate stepForInStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  // First, initialize a variable if exists.  Only do so once, ever.\r\n  if (!state.doneInit_) {\r\n    state.doneInit_ = true;\r\n    if (node['left']['declarations'] &&\r\n        node['left']['declarations'][0]['init']) {\r\n      if (state.scope.strict) {\r\n        this.throwException(this.SYNTAX_ERROR,\r\n            'for-in loop variable declaration may not have an initializer.');\r\n      }\r\n      // Variable initialization: for (var x = 4 in y)\r\n      return new Interpreter.MyState(node['left'], state.scope);\r\n    }\r\n  }\r\n  // Second, look up the object.  Only do so once, ever.\r\n  if (!state.doneObject_) {\r\n    state.doneObject_ = true;\r\n    if (!state.variable_) {\r\n      state.variable_ = state.value;\r\n    }\r\n    return new Interpreter.MyState(node['right'], state.scope);\r\n  }\r\n  if (!state.isLoop) {\r\n    // First iteration.\r\n    state.isLoop = true;\r\n    state.object_ = state.value;\r\n    state.visited_ = Object.create(null);\r\n  }\r\n  // Third, find the property name for this iteration.\r\n  if (state.name_ === undefined) {\r\n    done: do {\r\n      if (state.object_ && state.object_.isObject) {\r\n        if (!state.props_) {\r\n          state.props_ = Object.getOwnPropertyNames(state.object_.properties);\r\n        }\r\n        do {\r\n          var prop = state.props_.shift();\r\n        } while (prop && (state.visited_[prop] ||\r\n            !Object.prototype.hasOwnProperty.call(state.object_.properties,\r\n                                                  prop)));\r\n        if (prop) {\r\n          state.visited_[prop] = true;\r\n          if (Object.prototype.propertyIsEnumerable.call(\r\n              state.object_.properties, prop)) {\r\n            state.name_ = prop;\r\n            break done;\r\n          }\r\n        }\r\n      } else if (state.object_ !== null) {\r\n        if (!state.props_) {\r\n          state.props_ = Object.getOwnPropertyNames(state.object_);\r\n        }\r\n        do {\r\n          var prop = state.props_.shift();\r\n        } while (prop && state.visited_[prop]);\r\n        if (prop) {\r\n          state.visited_[prop] = true;\r\n          state.name_ = prop;\r\n          break done;\r\n        }\r\n      }\r\n      state.object_ = this.getPrototype(state.object_);\r\n      state.props_ = null;\r\n    } while (state.object_ !== null);\r\n    if (state.object_ === null) {\r\n      // Done, exit loop.\r\n      stack.pop();\r\n      return;\r\n    }\r\n  }\r\n  // Fourth, find the variable\r\n  if (!state.doneVariable_) {\r\n    state.doneVariable_ = true;\r\n    var left = node['left'];\r\n    if (left['type'] === 'VariableDeclaration') {\r\n      // Inline variable declaration: for (var x in y)\r\n      state.variable_ =\r\n          [Interpreter.SCOPE_REFERENCE, left['declarations'][0]['id']['name']];\r\n    } else {\r\n      // Arbitrary left side: for (foo().bar in y)\r\n      state.variable_ = null;\r\n      var nextState = new Interpreter.MyState(left, state.scope);\r\n      nextState.components = true;\r\n      return nextState;\r\n    }\r\n  }\r\n  if (!state.variable_) {\r\n    state.variable_ = state.value;\r\n  }\r\n  // Fifth, set the variable.\r\n  if (!state.doneSetter_) {\r\n    state.doneSetter_ = true;\r\n    var value = state.name_;\r\n    var setter = this.setValue(state.variable_, value);\r\n    if (setter) {\r\n      return this.createSetter_(setter, state.variable_, value);\r\n    }\r\n  }\r\n  // Next step will be step three.\r\n  state.name_ = undefined;\r\n  // Reevaluate the variable since it could be a setter on the global object.\r\n  state.doneVariable_ = false;\r\n  state.doneSetter_ = false;\r\n  // Sixth and finally, execute the body if there was one.  this.\r\n  if (node['body']) {\r\n    return new Interpreter.MyState(node['body'], state.scope);\r\n  }\r\n};\r\n\r\nprivate stepForStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var mode = state.mode_ || 0;\r\n  if (mode === 0) {\r\n    state.mode_ = 1;\r\n    if (node['init']) {\r\n      return new Interpreter.MyState(node['init'], state.scope);\r\n    }\r\n  } else if (mode === 1) {\r\n    state.mode_ = 2;\r\n    if (node['test']) {\r\n      return new Interpreter.MyState(node['test'], state.scope);\r\n    }\r\n  } else if (mode === 2) {\r\n    state.mode_ = 3;\r\n    if (node['test'] && !state.value) {\r\n      // Done, exit loop.\r\n      stack.pop();\r\n    } else {  // Execute the body.\r\n      state.isLoop = true;\r\n      return new Interpreter.MyState(node['body'], state.scope);\r\n    }\r\n  } else if (mode === 3) {\r\n    state.mode_ = 1;\r\n    if (node['update']) {\r\n      return new Interpreter.MyState(node['update'], state.scope);\r\n    }\r\n  }\r\n};\r\n\r\nprivate stepFunctionDeclaration(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  // This was found and handled when the scope was populated.\r\n  stack.pop();\r\n};\r\n\r\nprivate stepFunctionExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  stack[stack.length - 1].value = this.createFunction(<ESTree.FunctionDeclaration>node, state.scope);\r\n};\r\n\r\nprivate stepIdentifier(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  if (state.components) {\r\n    stack[stack.length - 1].value = [Interpreter.SCOPE_REFERENCE, node['name']];\r\n    return;\r\n  }\r\n  var value = this.getValueFromScope(node['name']);\r\n  // An identifier could be a getter if it's a property on the global object.\r\n  if (value && typeof value === 'object' && value.isGetter) {\r\n    // Clear the getter flag and call the getter function.\r\n    value.isGetter = false;\r\n    var scope = state.scope;\r\n    while (!this.hasProperty(scope, node['name'])) {\r\n      scope = scope.parentScope;\r\n    }\r\n    var func = /** @type {!Interpreter.Object} */ (value);\r\n    return this.createGetter_(func, this.global);\r\n  }\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepIfStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  return this.stepConditionalExpression(stack, state, node);\r\n}\r\n\r\nprivate stepLabeledStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  // No need to hit this node again on the way back up the stack.\r\n  stack.pop();\r\n  // Note that a statement might have multiple labels.\r\n  var labels = state.labels || [];\r\n  labels.push(node['label']['name']);\r\n  var nextState = new Interpreter.MyState(node['body'], state.scope);\r\n  nextState.labels = labels;\r\n  return nextState;\r\n};\r\n\r\nprivate stepLiteral(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  var value = node['value'];\r\n  if (value instanceof RegExp) {\r\n    var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\r\n    this.populateRegExp(pseudoRegexp, value);\r\n    value = pseudoRegexp;\r\n  }\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepLogicalExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (node['operator'] !== '&&' && node['operator'] !== '||') {\r\n    throw SyntaxError('Unknown logical operator: ' + node['operator']);\r\n  }\r\n  if (!state.doneLeft_) {\r\n    state.doneLeft_ = true;\r\n    return new Interpreter.MyState(node['left'], state.scope);\r\n  }\r\n  if (!state.doneRight_) {\r\n    if ((node['operator'] === '&&' && !state.value) ||\r\n        (node['operator'] === '||' && state.value)) {\r\n      // Shortcut evaluation.\r\n      stack.pop();\r\n      stack[stack.length - 1].value = state.value;\r\n    } else {\r\n      state.doneRight_ = true;\r\n      return new Interpreter.MyState(node['right'], state.scope);\r\n    }\r\n  } else {\r\n    stack.pop();\r\n    stack[stack.length - 1].value = state.value;\r\n  }\r\n};\r\n\r\nprivate stepMemberExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneObject_) {\r\n    state.doneObject_ = true;\r\n    return new Interpreter.MyState(node['object'], state.scope);\r\n  }\r\n  var propName;\r\n  if (!node['computed']) {\r\n    state.object_ = state.value;\r\n    // obj.foo -- Just access 'foo' directly.\r\n    propName = node['property']['name'];\r\n  } else if (!state.doneProperty_) {\r\n    state.object_ = state.value;\r\n    // obj[foo] -- Compute value of 'foo'.\r\n    state.doneProperty_ = true;\r\n    return new Interpreter.MyState(node['property'], state.scope);\r\n  } else {\r\n    propName = state.value;\r\n  }\r\n  stack.pop();\r\n  if (state.components) {\r\n    stack[stack.length - 1].value = [state.object_, propName];\r\n  } else {\r\n    var value = this.getProperty(state.object_, propName);\r\n    if (value && typeof value === 'object' && value.isGetter) {\r\n      // Clear the getter flag and call the getter function.\r\n      value.isGetter = false;\r\n      var func = /** @type {!Interpreter.Object} */ (value);\r\n      return this.createGetter_(func, state.object_);\r\n    }\r\n    stack[stack.length - 1].value = value;\r\n  }\r\n};\r\n\r\nprivate stepNewExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  return this.stepCallExpression(stack, state, node);\r\n}\r\n\r\nprivate stepObjectExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var property = node['properties'][n];\r\n  if (!state.object_) {\r\n    // First execution.\r\n    state.object_ = this.createObjectProto(this.OBJECT_PROTO);\r\n    state.properties_ = Object.create(null);\r\n  } else {\r\n    // Determine property name.\r\n    var key = <string>property['key'];\r\n    if (key['type'] === 'Identifier') {\r\n      var propName = key['name'];\r\n    } else if (key['type'] === 'Literal') {\r\n      var propName = key['value'];\r\n    } else {\r\n      throw SyntaxError('Unknown object structure: ' + key['type']);\r\n    }\r\n    // Set the property computed in the previous execution.\r\n    if (!state.properties_[propName]) {\r\n      // Create temp object to collect value, getter, and/or setter.\r\n      state.properties_[propName] = {};\r\n    }\r\n    state.properties_[propName][property['kind']] = state.value;\r\n    state.n_ = ++n;\r\n    property = node['properties'][n];\r\n  }\r\n  if (property) {\r\n    return new Interpreter.MyState(property['value'], state.scope);\r\n  }\r\n  for (var key in state.properties_) {\r\n    var kinds = state.properties_[key];\r\n    if ('get' in kinds || 'set' in kinds) {\r\n      // Set a property with a getter or setter.\r\n      var descriptor = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: kinds['get'],\r\n        set: kinds['set']\r\n      };\r\n      this.setProperty(state.object_, key, null, descriptor);\r\n    } else {\r\n      // Set a normal property with a value.\r\n      this.setProperty(state.object_, key, kinds['init']);\r\n    }\r\n  }\r\n  stack.pop();\r\n  stack[stack.length - 1].value = state.object_;\r\n};\r\n\r\nprivate stepProgram(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var expression = node['body'][n];\r\n  if (expression) {\r\n    state.done = false;\r\n    state.n_ = n + 1;\r\n    return new Interpreter.MyState(expression, state.scope);\r\n  }\r\n  state.done = true;\r\n  // Don't pop the stateStack.\r\n  // Leave the root scope on the tree in case the program is appended to.\r\n};\r\n\r\nprivate stepReturnStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (node['argument'] && !state.done_) {\r\n    state.done_ = true;\r\n    return new Interpreter.MyState(node['argument'], state.scope);\r\n  }\r\n  var value = state.value;\r\n  var i = stack.length - 1;\r\n  state = stack[i];\r\n  while (state.node['type'] !== 'CallExpression' &&\r\n         state.node['type'] !== 'NewExpression') {\r\n    if (state.node['type'] !== 'TryStatement') {\r\n      stack.splice(i, 1);\r\n    }\r\n    i--;\r\n    if (i < 0) {\r\n      // Syntax error, do not allow this error to be trapped.\r\n      throw SyntaxError('Illegal return statement');\r\n    }\r\n    state = stack[i];\r\n  }\r\n  state.value = value;\r\n};\r\n\r\nprivate stepSequenceExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var n = state.n_ || 0;\r\n  var expression = node['expressions'][n];\r\n  if (expression) {\r\n    state.n_ = n + 1;\r\n    return new Interpreter.MyState(expression, state.scope);\r\n  }\r\n  stack.pop();\r\n  stack[stack.length - 1].value = state.value;\r\n};\r\n\r\nprivate stepSwitchStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.test_) {\r\n    state.test_ = 1;\r\n    return new Interpreter.MyState(node['discriminant'], state.scope);\r\n  }\r\n  if (state.test_ === 1) {\r\n    state.test_ = 2;\r\n    // Preserve switch value between case tests.\r\n    state.switchValue_ = state.value;\r\n  }\r\n\r\n  while (true) {\r\n    var index = state.index_ || 0;\r\n    var switchCase = node['cases'][index];\r\n    if (!state.matched_ && switchCase && !switchCase['test']) {\r\n      // Test on the default case is null.\r\n      // Bypass (but store) the default case, and get back to it later.\r\n      state.defaultCase_ = index;\r\n      state.index_ = index + 1;\r\n      continue;\r\n    }\r\n    if (!switchCase && !state.matched_ && state.defaultCase_) {\r\n      // Ran through all cases, no match.  Jump to the default.\r\n      state.matched_ = true;\r\n      state.index_ = state.defaultCase_;\r\n      continue;\r\n    }\r\n    if (switchCase) {\r\n      if (!state.matched_ && !state.tested_ && switchCase['test']) {\r\n        state.tested_ = true;\r\n        return new Interpreter.MyState(switchCase['test'], state.scope);\r\n      }\r\n      if (state.matched_ || state.value === state.switchValue_) {\r\n        state.matched_ = true;\r\n        var n = state.n_ || 0;\r\n        if (switchCase['consequent'][n]) {\r\n          state.isSwitch = true;\r\n          state.n_ = n + 1;\r\n          return new Interpreter.MyState(switchCase['consequent'][n],\r\n                                       state.scope);\r\n        }\r\n      }\r\n      // Move on to next case.\r\n      state.tested_ = false;\r\n      state.n_ = 0;\r\n      state.index_ = index + 1;\r\n    } else {\r\n      stack.pop();\r\n      return;\r\n    }\r\n  }\r\n};\r\n\r\nprivate stepThisExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  stack.pop();\r\n  stack[stack.length - 1].value = this.getValueFromScope('this');\r\n};\r\n\r\nprivate stepThrowStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.done_) {\r\n    state.done_ = true;\r\n    return new Interpreter.MyState(node['argument'], state.scope);\r\n  } else {\r\n    this.throwException(state.value);\r\n  }\r\n};\r\n\r\nprivate stepTryStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneBlock_) {\r\n    state.doneBlock_ = true;\r\n    return new Interpreter.MyState(node['block'], state.scope);\r\n  }\r\n  if (state.throwValue && !state.doneHandler_ && node['handler']) {\r\n    state.doneHandler_ = true;\r\n    var nextState = new Interpreter.MyState(node['handler'], state.scope);\r\n    nextState.throwValue = state.throwValue;\r\n    state.throwValue = null;  // This error has been handled, don't rethrow.\r\n    return nextState;\r\n  }\r\n  if (!state.doneFinalizer_ && node['finalizer']) {\r\n    state.doneFinalizer_ = true;\r\n    return new Interpreter.MyState(node['finalizer'], state.scope);\r\n  }\r\n  if (state.throwValue) {\r\n    // There was no catch handler, or the catch/finally threw an error.\r\n    // Throw the error up to a higher try.\r\n    this.executeException(state.throwValue);\r\n  } else {\r\n    stack.pop();\r\n  }\r\n};\r\n\r\nprivate stepUnaryExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.done_) {\r\n    state.done_ = true;\r\n    var nextState = new Interpreter.MyState(node['argument'], state.scope);\r\n    nextState.components = node['operator'] === 'delete';\r\n    return nextState;\r\n  }\r\n  stack.pop();\r\n  var value = state.value;\r\n  if (node['operator'] === '-') {\r\n    value = -value;\r\n  } else if (node['operator'] === '+') {\r\n    value = +value;\r\n  } else if (node['operator'] === '!') {\r\n    value = !value;\r\n  } else if (node['operator'] === '~') {\r\n    value = ~value;\r\n  } else if (node['operator'] === 'delete') {\r\n    var result = true;\r\n    // If value is not an array, then it is a primitive, or some other value.\r\n    // If so, skip the delete and return true.\r\n    if (Array.isArray(value)) {\r\n      var obj = value[0];\r\n      if (obj === Interpreter.SCOPE_REFERENCE) {\r\n        // 'delete foo;' is the same as 'delete window.foo'.\r\n        obj = state.scope;\r\n      }\r\n      var name = String(value[1]);\r\n      try {\r\n        delete obj.properties[name];\r\n      } catch (e) {\r\n        if (state.scope.strict) {\r\n          this.throwException(this.TYPE_ERROR, \"Cannot delete property '\" +\r\n                              name + \"' of '\" + obj + \"'\");\r\n        } else {\r\n          result = false;\r\n        }\r\n      }\r\n    }\r\n    value = result;\r\n  } else if (node['operator'] === 'typeof') {\r\n    value = (value && value.class === 'Function') ? 'function' : typeof value;\r\n  } else if (node['operator'] === 'void') {\r\n    value = undefined;\r\n  } else {\r\n    throw SyntaxError('Unknown unary operator: ' + node['operator']);\r\n  }\r\n  stack[stack.length - 1].value = value;\r\n};\r\n\r\nprivate stepUpdateExpression(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneLeft_) {\r\n    state.doneLeft_ = true;\r\n    var nextState = new Interpreter.MyState(node['argument'], state.scope);\r\n    nextState.components = true;\r\n    return nextState;\r\n  }\r\n  if (!state.leftSide_) {\r\n    state.leftSide_ = state.value;\r\n  }\r\n  if (state.doneGetter_) {\r\n    state.leftValue_ = state.value;\r\n  }\r\n  if (!state.doneGetter_) {\r\n    var leftValue = this.getValue(state.leftSide_);\r\n    state.leftValue_ = leftValue;\r\n    if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\r\n      // Clear the getter flag and call the getter function.\r\n      leftValue.isGetter = false;\r\n      state.doneGetter_ = true;\r\n      var func = /** @type {!Interpreter.Object} */ (leftValue);\r\n      return this.createGetter_(func, state.leftSide_);\r\n    }\r\n  }\r\n  if (state.doneSetter_) {\r\n    // Return if setter function.\r\n    // Setter method on property has completed.\r\n    // Ignore its return value, and use the original set value instead.\r\n    stack.pop();\r\n    stack[stack.length - 1].value = state.doneSetter_;\r\n    return;\r\n  }\r\n  leftValue = Number(state.leftValue_);\r\n  var changeValue;\r\n  if (node['operator'] === '++') {\r\n    changeValue = leftValue + 1;\r\n  } else if (node['operator'] === '--') {\r\n    changeValue = leftValue - 1;\r\n  } else {\r\n    throw SyntaxError('Unknown update expression: ' + node['operator']);\r\n  }\r\n  var returnValue = node['prefix'] ? changeValue : leftValue;\r\n  var setter = this.setValue(state.leftSide_, changeValue);\r\n  if (setter) {\r\n    state.doneSetter_ = returnValue;\r\n    return this.createSetter_(setter, state.leftSide_, changeValue);\r\n  }\r\n  // Return if no setter function.\r\n  stack.pop();\r\n  stack[stack.length - 1].value = returnValue;\r\n};\r\n\r\nprivate stepVariableDeclaration(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  var declarations = node['declarations'];\r\n  var n = state.n_ || 0;\r\n  var declarationNode = declarations[n];\r\n  if (state.init_ && declarationNode) {\r\n    // This setValue call never needs to deal with calling a setter function.\r\n    // Note that this is setting the init value, not defining the variable.\r\n    // Variable definition is done when scope is populated.\r\n    this.setValueToScope(declarationNode['id']['name'], state.value);\r\n    state.init_ = false;\r\n    declarationNode = declarations[++n];\r\n  }\r\n  while (declarationNode) {\r\n    // Skip any declarations that are not initialized.  They have already\r\n    // been defined as undefined in populateScope_.\r\n    if (declarationNode['init']) {\r\n      state.n_ = n;\r\n      state.init_ = true;\r\n      return new Interpreter.MyState(declarationNode['init'], state.scope);\r\n    }\r\n    declarationNode = declarations[++n];\r\n  }\r\n  stack.pop();\r\n};\r\n\r\nprivate stepWithStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  if (!state.doneObject_) {\r\n    state.doneObject_ = true;\r\n    return new Interpreter.MyState(node['object'], state.scope);\r\n  } else if (!state.doneBody_) {\r\n    state.doneBody_ = true;\r\n    var scope = this.createSpecialScope(state.scope, state.value);\r\n    return new Interpreter.MyState(node['body'], scope);\r\n  } else {\r\n    stack.pop();\r\n  }\r\n};\r\n\r\nprivate stepWhileStatement(stack: Interpreter.MyState[], state: Interpreter.MyState, node: ESTree.Node) {\r\n  return this.stepDoWhileStatement(stack, state, node);\r\n}\r\n}\r\n\r\n// Preserve top-level API functions from being pruned/renamed by JS compilers.\r\n// Add others as needed.\r\n// The global object ('window' in a browser, 'global' in node.js) is 'this'.\r\nthis['Interpreter'] = Interpreter;\r\nInterpreter.prototype['step'] = Interpreter.prototype.step;\r\nInterpreter.prototype['run'] = Interpreter.prototype.run;\r\nInterpreter.prototype['appendCode'] = Interpreter.prototype.appendCode;\r\nInterpreter.prototype['createObject'] = Interpreter.prototype.createObject;\r\nInterpreter.prototype['createObjectProto'] =\r\n    Interpreter.prototype.createObjectProto;\r\nInterpreter.prototype['createAsyncFunction'] =\r\n    Interpreter.prototype.createAsyncFunction;\r\nInterpreter.prototype['createNativeFunction'] =\r\n    Interpreter.prototype.createNativeFunction;\r\nInterpreter.prototype['getProperty'] = Interpreter.prototype.getProperty;\r\nInterpreter.prototype['setProperty'] = Interpreter.prototype.setProperty;\r\nInterpreter.prototype['nativeToPseudo'] = Interpreter.prototype.nativeToPseudo;\r\nInterpreter.prototype['pseudoToNative'] = Interpreter.prototype.pseudoToNative;\r\n// Obsolete.  Do not use.\r\nInterpreter.prototype['createPrimitive'] = (x) => {return x;};\r\n\r\nmodule Interpreter {\r\n/**\r\n * Class for an object.\r\n * @param {Interpreter.MyObject} proto Prototype object or null.\r\n * @constructor\r\n */\r\nexport class MyObject {\r\n[key: string]: any;\r\ngetter: any;\r\nsetter: any;\r\nproperties: any;\r\n\r\nconstructor(proto) {\r\n  this.getter = Object.create(null);\r\n  this.setter = Object.create(null);\r\n  this.properties = Object.create(null);\r\n  this.proto = proto;\r\n}\r\n\r\n/** @type {Interpreter.MyObject} */\r\nproto: Interpreter.MyObject = null;\r\n\r\n/** @type {boolean} */\r\nisObject = true;\r\n\r\n/** @type {string} */\r\nclass = 'Object';\r\n\r\n/** @type {Date|RegExp|boolean|number|string|undefined|null} */\r\ndata: Date | RegExp | boolean | number | string | undefined | null = null;\r\n\r\n/**\r\n * Convert this object into a string.\r\n * @return {string} String value.\r\n * @override\r\n */\r\ntoString() {\r\n  if (this.class === 'Array') {\r\n    // Array\r\n    var cycles = Interpreter.toStringCycles_;\r\n    cycles.push(this);\r\n    try {\r\n      var strs = [];\r\n      for (var i = 0; i < this.properties.length; i++) {\r\n        var value = this.properties[i];\r\n        strs[i] = (value && value.isObject && cycles.indexOf(value) !== -1) ?\r\n            '...' : value;\r\n      }\r\n    } finally {\r\n      cycles.pop();\r\n    }\r\n    return strs.join(',');\r\n  }\r\n  if (this.class === 'Error') {\r\n    var cycles = Interpreter.toStringCycles_;\r\n    if (cycles.indexOf(this) !== -1) {\r\n      return '[object Error]';\r\n    }\r\n    var name, message;\r\n    // Bug: Does not support getters and setters for name or message.\r\n    var obj = <Interpreter.MyObject>this;\r\n    do {\r\n      if ('name' in obj.properties) {\r\n        name = obj.properties['name'];\r\n        break;\r\n      }\r\n    } while ((obj = obj.proto));\r\n    var obj = <Interpreter.MyObject>this;\r\n    do {\r\n      if ('message' in obj.properties) {\r\n        message = obj.properties['message'];\r\n        break;\r\n      }\r\n    } while ((obj = obj.proto));\r\n    cycles.push(this);\r\n    try {\r\n      name = name && name.toString();\r\n      message = message && message.toString();\r\n    } finally {\r\n      cycles.pop();\r\n    }\r\n    return message ? name + ': ' + message : String(name);\r\n  }\r\n\r\n  // RegExp, Date, and boxed primitives.\r\n  if (this.data !== null) {\r\n    return String(this.data);\r\n  }\r\n\r\n  return '[object ' + this.class + ']';\r\n}\r\n\r\n/**\r\n * Return the object's value.\r\n * @return {Interpreter.MyValue} Value.\r\n * @override\r\n */\r\nvalueOf() {\r\n  if (this.data === undefined || this.data === null ||\r\n      this.data instanceof RegExp) {\r\n    return this; // An Object.\r\n  }\r\n  if (this.data instanceof Date) {\r\n    return this.data.valueOf();  // Milliseconds.\r\n  }\r\n  return /** @type {(boolean|number|string)} */ (this.data);  // Boxed primitive.\r\n}\r\n}\r\n\r\n/**\r\n * Typedef for JS values.\r\n * @typedef {!Interpreter.MyObject|boolean|number|string|undefined|null}\r\n */\r\nexport type MyValue = MyObject | boolean | number | string | undefined | null;\r\n\r\n/**\r\n * Class for a state.\r\n * @param {!MyObject} node AST node for the state.\r\n * @param {!Interpreter.MyObject} scope Scope object for the state.\r\n * @constructor\r\n */\r\nexport class MyState {\r\n[key: string]: any;\r\nnode: ESTree.BaseNode;\r\nscope: Interpreter.MyObject;\r\nconstructor(node: ESTree.BaseNode, scope: Interpreter.MyObject) {\r\n  this.node = node;\r\n  this.scope = scope;\r\n}\r\n}\r\n\r\nexport interface MyValueTable {\r\n  pseudo: MyValue[],\r\n  native: any[]\r\n}\r\n}\r\n\r\n// These lines are added for API compatibility\r\nInterpreter['Object'] = Interpreter.MyObject;\r\nInterpreter['State'] = Interpreter.MyState;\r\n\r\nexport = Interpreter;\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib/interpreter.ts","// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Registered plugins\nvar plugins = {};\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n  var reserved = \"\";\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType == \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = keywordRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Load plugins\n  this.loadPlugins(options.plugins);\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false;\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0;\n  // Labels in scope.\n  this.labels = [];\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterFunctionScope();\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name]);\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name];\n    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n    plugin(this$1, pluginConfigs[name]);\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:[^']|\\.)*)'|\"((?:[^\"]|\\.)*)\"|;)/;\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this$1.input)[0].length;\n    var match = literal.exec(this$1.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) == \"use strict\") { return true }\n    start += match[0].length;\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(types.name)\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1;\n  if (!andThrow) { return pos >= 0 }\n  if (pos > -1) { this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this$1.parseStatement(true, true, exports);\n    node.body.push(stmt);\n  }\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function() {\n  if (this.type !== types.name || this.options.ecmaVersion < 6 || this.value != \"let\") { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  if (nextCh === 91 || nextCh == 123) { return true } // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!this.isKeyword(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.type !== types.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet()) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false)\n  case types._class:\n    if (!declaration) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (!declaration && kind != \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock()\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next();\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  this.enterLexicalScope();\n  this.expect(types.parenL);\n  if (this.type === types.semi) { return this.parseFor(node, null) }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init))\n      { return this.parseForIn(node, init$1) }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init);\n    this.checkLVal(init);\n    this.checkPatternErrors(refDestructuringErrors, true);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next();\n  return this.parseFunction(node, true, false, isAsync)\n};\n\npp$1.isFunction = function() {\n  return this.type === types._function || this.isAsyncFunction()\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction());\n  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.isFunction()) : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterLexicalScope();\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type != types.braceR;) {\n    if (this$1.type === types._case || this$1.type === types._default) {\n      var isCase = this$1.type === types._case;\n      if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this$1.startNode());\n      cur.consequent = [];\n      this$1.next();\n      if (isCase) {\n        cur.test = this$1.parseExpression();\n      } else {\n        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this$1.expect(types.colon);\n    } else {\n      if (!cur) { this$1.unexpected(); }\n      cur.consequent.push(this$1.parseStatement(true));\n    }\n  }\n  this.exitLexicalScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    this.expect(types.parenL);\n    clause.param = this.parseBindingAtom();\n    this.enterLexicalScope();\n    this.checkLVal(clause.param, \"let\");\n    this.expect(types.parenR);\n    clause.body = this.parseBlock(false);\n    this.exitLexicalScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this$1.labels[i];\n    if (label$1.statementStart == node.start) {\n      label$1.statementStart = this$1.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(true);\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && node.body.kind != \"var\" ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope) {\n  var this$1 = this;\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\n  var node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) {\n    this.enterLexicalScope();\n  }\n  while (!this.eat(types.braceR)) {\n    var stmt = this$1.parseStatement(true);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope();\n  }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  node.left = init;\n  node.right = this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type)\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this$1.startNode();\n    this$1.parseVarId(decl, kind);\n    if (this$1.eat(types.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected();\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n    if (!this$1.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind);\n  this.checkLVal(decl.id, kind, false);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    { node.generator = this.eat(types.star); }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type != types.name ? null : this.parseIdent();\n    if (node.id) {\n      this.checkLVal(node.id, \"var\");\n    }\n  }\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  if (!isStatement)\n    { node.id = this.type == types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next();\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (this$1.eat(types.semi)) { continue }\n    var method = this$1.startNode();\n    var isGenerator = this$1.eat(types.star);\n    var isAsync = false;\n    var isMaybeStatic = this$1.type === types.name && this$1.value === \"static\";\n    this$1.parsePropertyName(method);\n    method.static = isMaybeStatic && this$1.type !== types.parenL;\n    if (method.static) {\n      if (isGenerator) { this$1.unexpected(); }\n      isGenerator = this$1.eat(types.star);\n      this$1.parsePropertyName(method);\n    }\n    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== types.parenL &&\n        !this$1.canInsertSemicolon()) {\n      isAsync = true;\n      this$1.parsePropertyName(method);\n    }\n    method.kind = \"method\";\n    var isGetSet = false;\n    if (!method.computed) {\n      var key = method.key;\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== types.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true;\n        method.kind = key.name;\n        key = this$1.parsePropertyName(method);\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) { this$1.raise(key.start, \"Duplicate constructor in the same class\"); }\n        if (isGetSet) { this$1.raise(key.start, \"Constructor can't have get/set modifier\"); }\n        if (isGenerator) { this$1.raise(key.start, \"Constructor can't be a generator\"); }\n        if (isAsync) { this$1.raise(key.start, \"Constructor can't be an async method\"); }\n        method.kind = \"constructor\";\n        hadConstructor = true;\n      }\n    }\n    this$1.parseClassMethod(classBody, method, isGenerator, isAsync);\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1;\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start;\n        if (method.kind === \"get\")\n          { this$1.raiseRecoverable(start, \"getter should have no params\"); }\n        else\n          { this$1.raiseRecoverable(start, \"setter should have exactly one param\"); }\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          { this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n\n        this$1.checkUnreserved(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type;\n  if (type == \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type == \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this$1.checkPatternExport(exports, prop.value);\n      } }\n  else if (type == \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this$1.checkPatternExport(exports, elt); }\n    } }\n  else if (type == \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type == \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this$1.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this$1.startNode();\n    node.local = this$1.parseIdent(true);\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n    this$1.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, \"let\");\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, \"let\");\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this$1.startNode();\n    node$2.imported = this$1.parseIdent(true);\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent();\n    } else {\n      this$1.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this$1.checkLVal(node$2.local, \"let\");\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      if (prop.kind !== \"init\") { this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\"); }\n        this$1.toAssignable(prop.value, isBinding);\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding);\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length;\n  if (end) {\n    var last = exprList[end - 1];\n    if (last && last.type == \"RestElement\") {\n      --end;\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\";\n      var arg = last.argument;\n      this.toAssignable(arg, isBinding);\n      --end;\n    }\n\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this$1.toAssignable(elt, isBinding); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) { return this.parseIdent() }\n  switch (this.type) {\n  case types.name:\n    return this.parseIdent()\n\n  case types.bracketL:\n    var node = this.startNode();\n    this.next();\n    node.elements = this.parseBindingList(types.bracketR, true, true);\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case types.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this$1.expect(types.comma); }\n    if (allowEmpty && this$1.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === types.ellipsis) {\n      var rest = this$1.parseRestBinding();\n      this$1.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n      this$1.expect(close);\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n      this$1.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name);\n      } else {\n        this.declareLexicalName(expr.name);\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this$1.checkLVal(prop.value, bindingType, checkClashes);\n  }\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type == types.parenL || this.type == types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true);\n    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left) : left;\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start == startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors);\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.operator = this$1.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this$1.checkLVal(expr);\n      this$1.next();\n      expr = this$1.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon();\n  for (var computed = (void 0);;) {\n    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n      node.computed = !!computed;\n      if (computed) { this$1.expect(types.bracketR); }\n      base = this$1.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this$1.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\n      this$1.yieldPos = 0;\n      this$1.awaitPos = 0;\n      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false);\n        this$1.checkYieldAwaitInDefaultParams();\n        this$1.yieldPos = oldYieldPos;\n        this$1.awaitPos = oldAwaitPos;\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true);\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this$1.finishNode(node$1, \"CallExpression\");\n    } else if (this$1.type === types.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this$1.parseTemplate({isTagged: true});\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n    } else {\n      return base\n    }\n  }\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.inFunction)\n      { this.raise(this.start, \"'super' outside of function or class\"); }\n\n  case types._this:\n    var type = this.type === types._this ? \"ThisExpression\" : \"Super\";\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, type)\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc;\n    var id = this.parseIdent(this.type !== types.name);\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name) {\n        id = this.parseIdent();\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, false)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    while (this.type !== types.parenR) {\n      first ? first = false : this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this$1.type === types.ellipsis) {\n        spreadStart = this$1.start;\n        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n        if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        if (this$1.type === types.parenL && !innerParenStart) {\n          innerParenStart = this$1.start;\n        }\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (innerParenStart) { this.unexpected(innerParenStart); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n    if (!this.inFunction)\n      { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  var this$1 = this;\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this$1.expect(types.dollarBraceL);\n    node.expressions.push(this$1.parseExpression());\n    this$1.expect(types.braceR);\n    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0), startPos = (void 0), startLoc = (void 0);\n    if (this$1.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this$1.start;\n        startLoc = this$1.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this$1.eat(types.star); }\n    }\n    this$1.parsePropertyName(prop);\n    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && this$1.isAsyncProp(prop)) {\n      isAsync = true;\n      this$1.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors);\n    this$1.checkPropClash(prop, propHash);\n    node.properties.push(this$1.finishNode(prop, \"Property\"));\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != types.comma && this.type != types.braceR)) {\n    if (isGenerator || isAsync || isPattern) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    this.checkUnreserved(prop.key);\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.enterFunctionScope();\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = false;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.labels = oldLabels;\n  }\n  this.exitFunctionScope();\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\");\n  }\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var this$1 = this;\n\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this$1.type === types.comma)\n      { elt = null; }\n    else if (this$1.type === types.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this$1.start; }\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n  if (this.isKeyword(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") != -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name))\n    { this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\")); }\n};\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved == \"never\") { liberal = false; }\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) { this.checkUnreserved(node); }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type == types.semi || this.canInsertSemicolon() || (this.type != types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\n// Object.assign polyfill\nvar assign = Object.assign || function(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0, list = sources; i < list.length; i += 1) {\n    var source = list[i];\n\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n};\n\npp$5.exitFunctionScope = function() {\n  this.scopeStack.pop();\n};\n\npp$5.enterLexicalScope = function() {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n\n  this.scopeStack.push(childScope);\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n};\n\npp$5.exitLexicalScope = function() {\n  var childScope = this.scopeStack.pop();\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar);\n};\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n};\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n};\n\npp$5.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n};\n\npp$5.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType == types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType == types.arrow)\n    { return true }\n  if (prevType == types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType == types._var || prevType == types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this$1.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType == types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType == types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6) {\n    if (this.value == \"of\" && !this.exprAllowed ||\n        this.value == \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype;\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\";\n\n// Move to the next token\n\npp$8.next = function() {\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$8.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$8[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$8.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$8.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$8.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine;\n      this$1.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$8.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this$1.input.charCodeAt(++this$1.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this$1.pos;\n      break\n    case 13:\n      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n        ++this$1.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this$1.pos;\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n      case 42: // '*'\n        this$1.skipBlockComment();\n        break\n      case 47:\n        this$1.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this$1.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$8.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$8.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$8.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$8.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$8.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$8.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) { this.unexpected(); }\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$8.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$8.getTokenFromCode = function(code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n    // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n  case 63: ++this.pos; return this.finishToken(types.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n    // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp$8.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags)\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) { parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message); }\n      throw e\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\");\n\npp$8.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(start, \"Unterminated regular expression\"); }\n    var ch = this$1.input.charAt(this$1.pos);\n    if (lineBreak.test(ch)) { this$1.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this$1.pos;\n  }\n  var content = this.input.slice(start, this.pos);\n  ++this.pos;\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1();\n  var tmp = content, tmpFlags = \"\";\n  if (mods) {\n    var validFlags = /^[gim]*$/;\n    if (this.options.ecmaVersion >= 6) { validFlags = /^[gimuy]*$/; }\n    if (!validFlags.test(mods)) { this.raise(start, \"Invalid regular expression flag\"); }\n    if (mods.indexOf(\"u\") >= 0) {\n      if (regexpUnicodeSupport) {\n        tmpFlags = \"u\";\n      } else {\n        // Replace each astral symbol and every Unicode escape sequence that\n        // possibly represents an astral symbol or a paired surrogate with a\n        // single ASCII symbol to avoid throwing on regular expressions that\n        // are only valid in combination with the `/u` flag.\n        // Note: replacing with the ASCII symbol `x` might cause false\n        // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n        // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n        // be replaced by `[x-b]` which throws an error.\n        tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n          code = Number(\"0x\" + code);\n          if (code > 0x10FFFF) { this$1.raise(start + offset + 3, \"Code point out of bounds\"); }\n          return \"x\"\n        });\n        tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\");\n        tmpFlags = tmpFlags.replace(\"u\", \"\");\n      }\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null;\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, tmpFlags, start, this);\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods);\n  }\n  return this.finishToken(types.regexp, {pattern: content, flags: mods, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this$1.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$8.readRadixNumber = function(radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function(startsWithDot) {\n  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  if (octal && this.pos == start + 1) { octal = false; }\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    isFloat = true;\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    isFloat = true;\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos), val;\n  if (isFloat) { val = parseFloat(str); }\n  else if (!octal || str.length === 1) { val = parseInt(str, 10); }\n  else if (this.strict) { this.raise(start, \"Invalid number\"); }\n  else if (/[89]/.test(str)) { val = parseInt(str, 10); }\n  else { val = parseInt(str, 8); }\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$8.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(false);\n      chunkStart = this$1.pos;\n    } else {\n      if (isNewLine(ch)) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n      ++this$1.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$8.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$8.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$8.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated template\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this$1.pos += 2;\n          return this$1.finishToken(types.dollarBraceL)\n        } else {\n          ++this$1.pos;\n          return this$1.finishToken(types.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      return this$1.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(true);\n      chunkStart = this$1.pos;\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      ++this$1.pos;\n      switch (ch) {\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      chunkStart = this$1.pos;\n    } else {\n      ++this$1.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$8.readInvalidTemplateToken = function() {\n  var this$1 = this;\n\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this$1.input[this$1.pos]) {\n    case \"\\\\\":\n      ++this$1.pos;\n      break\n\n    case \"$\":\n      if (this$1.input[this$1.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n        this.invalidStringToken(this.pos - 2, \"Octal literal in strict mode\");\n      }\n      this.pos += octalStr.length - 1;\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true;\n      word += this$1.input.slice(chunkStart, this$1.pos);\n      var escStart = this$1.pos;\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        { this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this$1.pos;\n      var esc = this$1.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this$1.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this$1.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.1.1\";\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nvar parse_dammit;\nvar LooseParser;\nvar pluginsLoose; // eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser$$1, plugins$$1) {\n  parse_dammit = parse; // eslint-disable-line camelcase\n  LooseParser = Parser$$1;\n  pluginsLoose = plugins$$1;\n}\n\nexport { version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/acorn/dist/acorn.es.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}